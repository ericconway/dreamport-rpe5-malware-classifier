import collections
import os
import re
import sys
import time

__version__ = '0.1'
__enabled__ = True

MIN_STR_LEN = 6
MIN_WRD_LEN = 4
TIMEOUT = 60*2

SPECIAL_STRING_REGEXS = [
    re.compile('[0-9a-zA-Z]{1,32}(%s[0-9a-zA-Z]{1,32}){1,32}' % separator) for separator in ['\\.', '\\', '/', '-', ':']
    # examples: www.thing.com, YYYY-MM-DD, NN:NN:NN, path/to/somewhere
]


class RunTimeout(Exception):
    pass


def run(filepath='', fileinfo=None, temppath='./temp', **kwargs):
    start_time = time.time()
    with open(filepath, 'rb') as f:
        content = f.read()

    # namespace the temp path
    temppath = os.path.join(temppath, 'strings')
    if not os.path.exists(temppath):
        os.makedirs(temppath)

    strings = collections.Counter()
    words = collections.Counter()
    specials = collections.Counter()

    # extract any byte arrays encoded in string
    extracted_bytes = bytearray()
    for b in re.finditer(b'0x[0-9a-fA-F]{2}\\b', content):
        extracted_bytes.append(int(b.group(0), 16))
    if len(extracted_bytes) > 100:
        specials['special: '+'Long byte array'] += 1
        with open(os.path.join(temppath, 'extracted_byte_array.bin'), 'wb') as f:
            f.write(extracted_bytes)

    try:
        for st in re.finditer(b'[\x20-\x7e]{%d,}' % MIN_STR_LEN, content):
            st = st.group(0).decode('utf-8', errors='replace')

            if time.time() - start_time > TIMEOUT:
                raise RunTimeout('regex')

            # normalize encoding
            if re.search(r'\\x[2-7][0-9a-fA-F]\b', st):
                specials['special: '+'encoded string'] += 1
                specials['special: '+'\\x encoded string found'] += 1
                for c in range(0x20, 0x7e):
                    st = st.replace('\\x%02x' % c, chr(c))
            if re.search(r'0x[2-7][0-9a-fA-F]\b', st):
                specials['special: '+'encoded string'] += 1
                specials['special: '+'0x encoded string found'] += 1
                for c in reversed(range(0x20, 0x7e)):
                    st = st.replace('0x%02x, ' % c, chr(c))  # with comma space
                    st = st.replace('0x%02x,' % c, chr(c))  # with just comma
                    st = st.replace('0x%02x' % c, chr(c))  # just the hex code

            # split long lines of minified text
            st = st.replace('><', '>;<')  # so we split minified html
            for s in st.split(';'):  # so we split minified javascript
                s = s.strip()  # so we aren't thrown by indentation
                if len(s) >= MIN_STR_LEN:
                    strings[s] += 1
                if time.time() - start_time > TIMEOUT:
                    raise RunTimeout('strings')

            # words
            for wd in re.finditer('[a-zA-Z]{%d,}' % MIN_WRD_LEN, st):
                wd = wd.group(0).lower()
                words['word: '+wd] += 1
                if time.time() - start_time > TIMEOUT:
                    raise RunTimeout('words')

            # special strings
            if 'buf = ' in st:
                specials['special: ' + 'buffer assignment found'] += 1
            if ('This program cannot' in st) or ('DOS mode' in st):
                specials['special: '+'DOS header string'] += 1
            for regex in SPECIAL_STRING_REGEXS:
                for m in regex.finditer(st):
                    specials['special: '+m.group(0)] += 1
                    if time.time() - start_time > TIMEOUT:
                        raise RunTimeout('specials')

    except RunTimeout as e:
        print('    WARNING: Timeout expired for %s.run("%s") #%s' % (__name__, filepath, str(e)))

    features = strings + words + specials
    print("    %s produced %d features in %0.1f seconds" % (__name__, len(features), time.time()-start_time))
    return features


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print('Usage: %s filepath' % sys.argv[0])
        exit(-1)
    features = run(sys.argv[1])
    for f in features:
        print(f)
