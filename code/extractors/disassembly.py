import collections
import re
import subprocess
import zlib

__version__ = '0.1'
__enabled__ = True

NGRAM_LEN = 5
DECIMATION = 20

# Choice of disassembler:
#    objdump is over 20x faster
#    radare2 is more accurate
DISASSEMBLER = 'radare2'  # 'objdump'


def run(filepath='', fileinfo=None, **kwargs):
    print("    %s.run()" % __name__)
    features = collections.Counter()

    # supported file type?
    if fileinfo:
        if 'type' in fileinfo:
            unsupported = ['text', 'archive', 'data']
            if any([u in fileinfo['type'] for u in unsupported]):
                return features

    assembly = []

    if DISASSEMBLER == 'objdump':
        cmd = ['objdump', '--disassemble', filepath]
    elif DISASSEMBLER == 'radare2':
        cmd = [
            'r2',  # radare2
            '-A',  # Analyze all (aaa command)
            '-q',  # quiet, don't ask questions and quit when done
            '-c',  # execute following command
            'e scr.color=0;pi @@ *func*;pi @@ *sub*;pi @@ *fcn*',
            # set screen colors off, print instructions for all functions/subroutines
            filepath,
        ]

    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = proc.communicate()
    for line in stdout.splitlines():

        # general cleanup
        line = line.decode('utf-8', errors='replace').strip()

        if DISASSEMBLER == 'objdump':
            tokens = line.split('\t')
            if len(tokens) < 3:
                continue

            # remove address and bytes, keep mnemonic and args
            line = ' '.join(tokens[2:]).strip()

            # remove numbers (addresses and offsets are too fragile and position dependent)
            line = re.sub('0x[a-f0-9]*', '', line)
            line = re.sub('[0-9]*', '', line)

        elif DISASSEMBLER == 'radare2':
            line = re.sub('0x[a-f0-9]*', '', line)

        # skip nops
        if line.lower().startswith('nop'):
            continue

        assembly.append(line)

    for i in range(len(assembly)-NGRAM_LEN):
        ng = ';'.join(assembly[i:i+NGRAM_LEN])

        # decimate, don't save all ngrams
        if zlib.crc32(ng.encode('utf-8')) % DECIMATION == 0:
            features[ng] += 1

    # add in any errors:
    for line in stderr.splitlines():
        line = line.decode('utf-8', errors='replace').strip()
        features[line] += 1

    return features


if __name__ == "__main__":
    """
    code below in progress.  idea: extract javascript/html keywords as "instructions" and capture ngrams
    """
    import glob
    import os
    import sys

    keywords_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'keywords')
    keyword_files = glob.glob(os.path.join(keywords_path, 'keywords*.txt'))

    keywords = []
    for keyword_file in keyword_files:
        with open(keyword_file,'rt') as f:
            content = f.read()
        for line in content.splitlines():
            keyword = line.split('#', 1)[0].strip()  # remove any comment
            if not keyword:
                continue
            keyword = keyword.lower()
            if not keyword.startswith('<'):
                keyword = '\\b'+keyword+'\\b'  # slash 'b' is regex for word boundary
            keywords.append(keyword)
    keyword_regex = re.compile('|'.join(keywords))

    with open(sys.argv[1], 'rt') as f:
        content = f.read()
    for match in keyword_regex.finditer(content.lower()):
        print(match.group(0))
