import os
import random
import zlib

__version__ = '0.1'
__enabled__ = True

MIN_HASH_LEN = 100
MIN_HASH_INIT = 0

random.seed(MIN_HASH_INIT)
MIN_HASH_SEEDS = [random.randint(0, 65535).to_bytes(4, 'little') for _ in range(MIN_HASH_LEN)]

gDataBase = None


def min_hash(feature_list):
    if not feature_list:
        return []
    return [min([zlib.crc32(hash_seed+feature.encode('utf-8'))&0xffffffff for feature in feature_list]) for hash_seed in MIN_HASH_SEEDS]


def compare_min_hash(mh1, mh2):
    mhlen = min(len(mh1), len(mh2))
    if mhlen <= 0:
        return 0.0
    return sum([mh1[i] == mh2[i] for i in range(mhlen)]) / mhlen


def compare_files(data1, data2):
    comparison = {
        'file1': {
            'filepath': data1['filepath'],
            'fileinfo': data1['fileinfo'],
        },
        'file2': {
            'filepath': data2['filepath'],
            'fileinfo': data2['fileinfo'],
        },
        'score': 0.0,
        'scores': [],
    }
    cumulative_score = 0.0
    count = 0.0
    for plugin1 in data1['plugins']:
        try:
            plugins2 = data2['plugins'][0]['results']['plugins']
        except TypeError:
            print('Warning: malformed identity.minhash file for '+data2['fileinfo']['md5'])
            plugins2 = []
        for plugin2 in plugins2:
            if plugin1['plugin'] == plugin2['plugin']:
                if (not plugin1['results']) or (not plugin2['results']):
                    continue
                score = compare_min_hash(plugin1['results'], plugin2['results'])
                count += 1.0
                cumulative_score += score
                comparison['scores'].append({
                    'plugin': plugin1['plugin'],
                    'score': score,
                })
    comparison['score'] = cumulative_score / max(count, 1.0)
    return comparison


def find_matches(data1, storage):
    global gDataBase
    if gDataBase is None:
        gDataBase = storage.load_all('identities/minhashes')
    score_data = [compare_files(data1, data2) for data2 in gDataBase if data1['fileinfo']['md5'] != data2['fileinfo']['md5']]
    score_data = [sd for sd in score_data if sd['score'] > 0.5]
    score_data = sorted(score_data, key=lambda k: k['score'], reverse=True)
    return score_data[0:10]


def run(filepath='', fileinfo=None, **kwargs):
    # print("%s.run(%s, %s, %s)"%(__name__, filepath, fileinfo, kwargs))

    feature_data = kwargs['feature_data']
    training = kwargs['training']
    storage = kwargs['storage']

    for plugin_data in feature_data['plugins']:
        mh = min_hash(plugin_data['results'].keys())
        plugin_data['results'] = mh

    if not training:
        matches = find_matches(feature_data, storage)
        if matches:
            print('    Similar files:')
        for match in matches:
            subscores = []
            for sd in match['scores']:
                subscores.append('%s %d'%(sd['plugin'].split('.')[-1], sd['score']*100))
            match_path = match['file2']['filepath']
            match_md5 = match['file2']['fileinfo']['md5']
            msg = '        MD5:%s, file:%s, score:%d (%s) ' %(match_md5, match_path, match['score']*100, ', '.join(subscores))
            print(msg)

    return feature_data
