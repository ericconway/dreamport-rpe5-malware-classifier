{
    "filepath": "/home/chris/data/rpe005/malware_samples_exercise/20190522_110020_rpe005_malware_alert/string[1].js",
    "fileinfo": {
        "labels": {
            "family": "bad_sample_6",
            "software": "test_file"
        },
        "md5": "76bbcbac9dbd94c6dd84e74565d0bfdc",
        "type": "UTF-8 Unicode text",
        "clamav": "OK",
        "blobs": "Extracted 2 blobs (1 ISO-8859, 1 UTF-8)"
    },
    "plugins": [
        {
            "plugin": "extractors.disassembly",
            "version": "0.1",
            "results": {}
        },
        {
            "plugin": "extractors.strings",
            "version": "0.1",
            "results": {
                "* jquery.string - Prototype string functions for jQuery": 1,
                "* version: 1.1.0": 1,
                "* (c) 2008-2011 David E. Still (http://stilldesigning.com)": 1,
                "* Original Prototype extensions (c) 2005-2011 Sam Stephenson (http://prototypejs.org)": 1,
                "(function($){": 1,
                "$.extend({": 1,
                "__stringPrototype: function(str){": 1,
                "var splitCheck = (\"a b\".split(/\\w/)[0] == \" \")": 1,
                "// test for crappy IE matching (feature sniffing instead of version sniffing)": 1,
                "function makeRegExpGlobal(p) {": 1,
                "if (!p.source) { return p": 1,
                "var mods = \"g\"+((p.ignoreCase)?\"i\":\"\")+((p.multiline)?\"m\":\"\")": 1,
                "return new RegExp(p.source, mods)": 1,
                "this.str = str": 1,
                "* ScriptFragmet, specialChar, and JSONFilter borrowed from Prototype 1.6.0.2": 1,
                "this.JSONFilter = /^\\/\\*-secure-([\\s\\S]*)\\*\\/\\s*$/": 1,
                "this.ScriptFragment = '<script[^>]*>([\\\\S\\\\s]*?)<\\/script>'": 1,
                "this.specialChar = {": 1,
                "'\\b': '\\\\b',": 1,
                "'\\t': '\\\\t',": 1,
                "'\\n': '\\\\n',": 1,
                "'\\f': '\\\\f',": 1,
                "'\\r': '\\\\r',": 1,
                "'\\\\': '\\\\\\\\'": 1,
                "* Check if the string is blank (white-space only or empty).": 1,
                "* @param {String} s string to be evaluated": 28,
                "* @return {Boolean} boolean of result": 7,
                "this.blank = function(s) {": 1,
                "return /^\\s*$/.test(this.s(s) || ' ')": 1,
                "* Converts a string separated by dashes into a camelCase equivalent.": 1,
                "* For instance, 'foo-bar' would be converted to 'fooBar'.": 1,
                "this.camelize = function(s) {": 1,
                "var a = this.s(s).split('-'), i": 1,
                "s = [a[0]]": 3,
                "for (i=1": 3,
                "i<a.length": 2,
                "s.push(a[i].charAt(0).toUpperCase() + a[i].substring(1))": 1,
                "this.str = s.join('')": 1,
                "return this": 41,
                "* Capitalizes the first letter of a string and downcases all the others.": 1,
                "this.capitalize = function(s) {": 1,
                "s = this.s(s)": 13,
                "this.str = s.charAt(0).toUpperCase() + s.substring(1).toLowerCase()": 1,
                "* Replaces every instance of the underscore character (\"_\") by a dash (\"-\").": 1,
                "this.dasherize = function(s) {": 1,
                "this.str = this.s(s).split('_').join('-')": 1,
                "* Check if the string is empty.": 1,
                "this.empty = function(s) {": 1,
                "return (s)?(s==''):(this.str=='')": 1,
                "* Tests whether the end of a string matches pattern.": 1,
                "* @param {Object} pattern": 2,
                "this.endsWith = function(pattern, s) {": 1,
                "var d = s.length - pattern.length": 1,
                "return d >= 0 && s.lastIndexOf(pattern) === d": 1,
                "* escapeHTML from Prototype-1.6.0.2 -- If it's good enough for Webkit and IE, it's good enough for Gecko!": 1,
                "* Converts HTML special characters to their entity equivalents.": 1,
                "* @return {Object} .string object (or string if internal)": 18,
                "this.escapeHTML = function(s) {": 1,
                "this.str = this.s(s)": 1,
                ".split('&').join('&amp": 1,
                ".split('<').join('&lt": 1,
                ".split('>').join('&gt": 1,
                "* evalJSON from Prototype-1.6.0.2": 1,
                "* Evaluates the JSON in the string and returns the resulting object. If the optional sanitize parameter": 1,
                "* is set to true, the string is checked for possible malicious attempts and eval is not called if one": 1,
                "* is detected.": 1,
                "* @return {Object} evaluated JSON result": 1,
                "this.evalJSON = function(sanitize, s) {": 1,
                "var json = this.unfilterJSON(false, s).str": 1,
                "if (!sanitize || this.isJSON(json)) {": 1,
                "return eval('(' + json + ')')": 1,
                "} catch (e) { }": 1,
                "throw new SyntaxError('Badly formed JSON string: ' + s)": 1,
                "* evalScripts from Prototype-1.6.0.2": 1,
                "* Evaluates the content of any script block present in the string. Returns an array containing": 1,
                "* the value returned by each script.": 1,
                "this.evalScripts = function(s) {": 1,
                "var scriptTags = this.extractScripts(this.s(s)), results = []": 1,
                "if (scriptTags.length > 0) {": 1,
                "for (var i = 0": 2,
                "i < scriptTags.length": 1,
                "i++) {": 4,
                "results.push(eval(scriptTags[i]))": 1,
                "return results": 1,
                "* extractScripts from Prototype-1.6.0.2": 1,
                "* Extracts the content of any script block present in the string and returns them as an array of strings.": 1,
                "this.extractScripts = function(s) {": 1,
                "var matchAll = new RegExp(this.ScriptFragment, 'img'), matchOne = new RegExp(this.ScriptFragment, 'im'), scriptMatches = this.s(s).match(matchAll) || [], scriptTags = []": 1,
                "if (scriptMatches.length > 0) {": 1,
                "i < scriptMatches.length": 1,
                "scriptTags.push(scriptMatches[i].match(matchOne)[1] || '')": 1,
                "return scriptTags": 1,
                "* Returns a string with all occurances of pattern replaced by either a regular string": 1,
                "* or the returned value of a function.  Calls sub internally.": 1,
                "* @param {Object} pattern RegEx pattern or string to replace": 3,
                "* @param {Object} replacement string or function to replace matched patterns": 3,
                "* @see sub": 2,
                "this.gsub = function(pattern, replacement, s) {": 1,
                "if ($.isFunction(replacement)) {": 2,
                "var match = s.match(makeRegExpGlobal(pattern))": 1,
                "if (match == null) { return this": 1,
                "s = this.sub(pattern, replacement, match.length, s).str": 1,
                "/* if replacement is not a function, do this the easy way": 1,
                "it's quicker */": 1,
                "else { s = s.split(pattern).join(replacement)": 1,
                "this.str = s": 6,
                "* Check if the string contains a substring.": 1,
                "* @param {Object} pattern RegEx pattern or string to find": 1,
                "* @return {Boolean} boolean result": 2,
                "this.include = function(pattern, s) {": 1,
                "return this.s(s).indexOf(pattern) > -1": 1,
                "* Returns a debug-oriented version of the string (i.e. wrapped in single or double quotes,": 1,
                "* with backslashes and quotes escaped).": 1,
                "* @param {Object} useDoubleQuotes escape double-quotes instead of single-quotes": 1,
                "this.inspect = function(useDoubleQuotes, s) {": 1,
                "var specialChar = this.specialChar,": 1,
                "escapedString = this.gsub(/[\\x00-\\x1f\\\\]/, function(match) {": 1,
                "var character = specialChar[match[0]]": 1,
                "return character ? character : '\\\\u00' + match[0].charCodeAt().toPaddedString(2, 16)": 1,
                "}, s).str": 3,
                "this.str = (useDoubleQuotes) ? '\"' + escapedString.replace(/\"/g, '\\\\\"') + '\"' : \"'\" + escapedString.replace(/'/g, '\\\\\\'') + \"'\"": 1,
                "* Treats the string as a Prototype-style Template and fills it with object": 1,
                "s properties.": 1,
                "* @param {Object} obj object of values to replace in string": 1,
                "* @param {Object} pattern RegEx pattern for template replacement (default matches Ruby-style '#{attribute}')": 1,
                "this.interpolate = function(obj, pattern, s) {": 1,
                "if (!pattern) { pattern = /(^|.|\\r|\\n)(\\#\\{\\s*(\\w+)\\s*\\})/": 3,
                "var count = 0,": 1,
                "length = s.length,": 1,
                "while (pattern.match(s) && count++ < length) {": 1,
                "match = pattern.exec(s)": 1,
                "s = this.gsub(match[2],obj[match[3]], s).str": 1,
                "* isJSON from Prototype-1.6.0.2": 1,
                "* Check if the string is valid JSON by the use of regular expressions. This security method is called internally.": 1,
                "this.isJSON = function(s) {": 1,
                "if (this.blank(s)) { return false": 2,
                "s = s.replace(/\\\\./g, '@').replace(/\"[^\"\\\\\\n\\r]*\"/g, '')": 1,
                "return (/^[,:{}\\[\\]0-9.\\-+Eaeflnr-u \\n\\r\\t]*$/).test(s)": 1,
                "* Evaluates replacement for each match of pattern in string and returns the original string.": 1,
                "* Calls sub internally.": 1,
                "this.scan = function(pattern, replacement, s) {": 1,
                "this.gsub(pattern, replacement, s).str = s": 1,
                "* Tests whether the beginning of a string matches pattern.": 1,
                "this.startsWith = function(pattern, s) {": 1,
                "return this.s(s).indexOf(pattern) === 0": 1,
                "* Trims white space from the beginning and end of a string.": 1,
                "this.strip = function(s) {": 1,
                "this.str = $.trim(this.s(s))": 1,
                "* Strips a string of anything that looks like an HTML script block.": 1,
                "this.stripScripts = function(s) {": 1,
                "this.str = this.s(s).replace(new RegExp(this.ScriptFragment, 'img'), '')": 1,
                "* Strips a string of any HTML tags.": 1,
                "this.stripTags = function(s) {": 1,
                "this.str = this.s(s).replace(/<\\/?[^>]+>/gi, '')": 1,
                "* Returns a string with the first count occurances of pattern replaced by either a regular string": 1,
                "* or the returned value of a function.": 1,
                "* @param {Integer} count number of (default = 1, -1 replaces all)": 1,
                "this.sub = function(pattern, replacement, count, s) {": 1,
                "count = (!count)?1:count": 3,
                "if (count < 0 || isNaN(count)) { return this": 1,
                "// make RegExp global": 1,
                "pattern = makeRegExpGlobal(pattern)": 1,
                "var sarray = s.split(pattern), matches = s.match(pattern)": 1,
                "if (splitCheck && typeof(pattern) == \"object\") {": 1,
                "if (count == matches.length) ++count": 1,
                "if (s.indexOf(matches[0]) == 0) sarray.unshift(\"\")": 1,
                "if (s.lastIndexOf(matches[matches.length-1]) == s.length - matches[matches.length-1].length) sarray.push(\"\")": 1,
                "s = sarray[0]": 1,
                "for (var i=1": 2,
                "i<sarray.length": 2,
                "if (i <= count) {": 1,
                "s += replacement(matches[i-1] || matches) + sarray[i]": 1,
                "} else { s += replacement + sarray[i]": 1,
                "} else { s += (matches[i-1] || matches) + sarray[i]": 1,
                "* succ from Prototype-1.6.0.2": 1,
                "this.succ = function(s) {": 1,
                "this.str = s.slice(0, s.length - 1) + String.fromCharCode(s.charCodeAt(s.length - 1) + 1)": 1,
                "* times from Prototype-1.6.0.2": 1,
                "* Concatenate count number of copies of s together and return result.": 1,
                "* @param {Integer} count Number of times to repeat s": 1,
                "this.times = function(count, s) {": 1,
                "this.str = count < 1 ? \"\" : (new Array(count + 1)).join(this.s(s))": 1,
                "* Returns a JSON string": 1,
                "this.toJSON = function(s) {": 1,
                "return this.inspect(true, this.s(s))": 1,
                "* Parses a URI-like query string and returns an object composed of parameter/value pairs.": 1,
                "* This method is mainly targeted at parsing query strings (hence the default value of '&'": 1,
                "* for the seperator argument). For this reason, it does not consider anything that is either": 1,
                "* before a question mark (which signals the beginning of a query string) or beyond the hash": 1,
                "* symbol (\"#\"), and runs decodeURIComponent() on each parameter/value pair.": 1,
                "* @param {Object} separator string to separate parameters (default = '&')": 1,
                "* @param {Object} s": 1,
                "* @return {Object} object": 1,
                "this.toQueryParams = function(separator, s) {": 1,
                "var paramsList = s.substring(s.indexOf('?')+1).split('#')[0].split(separator || '&'), params = {}, i, key, value, pair": 1,
                "for (i=0": 2,
                "i<paramsList.length": 1,
                "pair = paramsList[i].split('=')": 1,
                "key = decodeURIComponent(pair[0])": 1,
                "value = (pair[1])?decodeURIComponent(pair[1]):undefined": 1,
                "if (params[key]) {": 1,
                "if (typeof params[key] == \"string\") { params[key] = [params[key]]": 1,
                "params[key].push(value)": 1,
                "} else { params[key] = value": 1,
                "return params": 1,
                "* truncate from Prototype-1.6.0.2": 1,
                "* Truncates a string to the given length and appends a suffix to it (indicating that it is only an excerpt).": 1,
                "* @param {Object} length length of string to truncate to": 1,
                "* @param {Object} truncation string to concatenate onto truncated string (default = '...')": 1,
                "this.truncate = function(length, truncation, s) {": 1,
                "length = length || 30": 1,
                "truncation = (!truncation) ? '...' : truncation": 1,
                "s = (s.length > length) ? s.slice(0, length - truncation.length) + truncation : String(s)": 1,
                "* underscore from Prototype-1.6.0.2": 1,
                "* Converts a camelized string into a series of words separated by an underscore (\"_\").": 1,
                "* e.g. $.string('borderBottomWidth').underscore().str = 'border_bottom_width'": 1,
                "this.underscore = function(s) {": 1,
                "//s = this.s(s)": 1,
                "//this.str = $.string(s).gsub(/::/, \"/\").gsub(/([A-Z]+)([A-Z][a-z])/, \"#{1}_#{2}\").gsub(/([a-z\\d])([A-Z])/, \"#{1}_#{2}\").gsub(/-/, \"_\").str.toLowerCase()": 1,
                "this.gsub(/[A-Z]/, function(m){ return \"_\" + m.toLowerCase()": 1,
                "}, this.s(s))": 3,
                "if (this.str.substring(0,1) == \"_\") {": 1,
                "this.str = this.str.substring(1)": 1,
                "* unescapeHTML from Prototype-1.6.0.2 -- If it's good enough for Webkit and IE, it's good enough for Gecko!": 1,
                "* Strips tags and converts the entity forms of special HTML characters to their normal form.": 1,
                "this.unescapeHTML = function(s) {": 1,
                "this.str = this.stripTags(this.s(s)).str.replace(/&amp": 1,
                "/g,'&').replace(/&lt": 1,
                "/g,'<').replace(/&gt": 1,
                "/g,'>')": 2,
                "* unfilterJSON from Prototype-1.6.0.2.": 1,
                "* @param {Function} filter": 1,
                "this.unfilterJSON = function(filter, s) {": 1,
                "filter = filter || this.JSONFilter": 1,
                "var filtered = s.match(filter)": 3,
                "this.str = (filtered !== null)?filtered[1]:s": 3,
                "* value -- convenience method to return .str": 1,
                "this.value = function() {": 1,
                "return this.str": 1,
                "* fetch str internally if no parameter is given": 1,
                "this.s = function(s) {": 1,
                "return (s)?s:this.str": 1,
                "string: function(str) {": 1,
                "if (str === String.prototype) { $.extend(String.prototype, new $.__stringPrototype())": 1,
                "else { return new $.__stringPrototype(str)": 1,
                "$.__stringPrototype.parseQuery = $.__stringPrototype.toQueryParams": 1,
                "})(jQuery)": 1,
                "word: jquery": 9,
                "word: string": 346,
                "word: prototype": 46,
                "word: functions": 3,
                "word: version": 9,
                "word: stilldesigning": 3,
                "word: original": 5,
                "word: extensions": 3,
                "word: stephenson": 3,
                "word: prototypejs": 3,
                "word: function": 110,
                "word: extend": 6,
                "word: stringprototype": 15,
                "word: splitcheck": 5,
                "word: crappy": 3,
                "word: matching": 3,
                "word: feature": 3,
                "word: sniffing": 6,
                "word: instead": 6,
                "word: makeregexpglobal": 7,
                "word: source": 6,
                "word: return": 168,
                "word: ignorecase": 3,
                "word: multiline": 3,
                "word: regexp": 11,
                "word: scriptfragmet": 3,
                "word: specialchar": 15,
                "word: jsonfilter": 9,
                "word: borrowed": 3,
                "word: secure": 3,
                "word: scriptfragment": 9,
                "word: script": 14,
                "word: evaluated": 70,
                "word: boolean": 40,
                "word: result": 25,
                "word: converts": 12,
                "word: separated": 6,
                "word: dashes": 3,
                "word: camelcase": 3,
                "word: equivalent": 3,
                "word: instance": 5,
                "word: converted": 3,
                "word: foobar": 3,
                "word: camelize": 3,
                "word: length": 66,
                "word: charat": 4,
                "word: touppercase": 4,
                "word: substring": 14,
                "word: capitalizes": 2,
                "word: letter": 2,
                "word: downcases": 2,
                "word: others": 2,
                "word: capitalize": 2,
                "word: tolowercase": 8,
                "word: replaces": 5,
                "word: underscore": 14,
                "word: character": 11,
                "word: dasherize": 2,
                "word: whether": 4,
                "word: matches": 29,
                "word: pattern": 93,
                "word: object": 145,
                "word: endswith": 2,
                "word: lastindexof": 5,
                "word: escapehtml": 6,
                "word: enough": 12,
                "word: webkit": 6,
                "word: special": 6,
                "word: characters": 6,
                "word: entity": 6,
                "word: equivalents": 3,
                "word: internal": 44,
                "word: evaljson": 6,
                "word: evaluates": 8,
                "word: returns": 22,
                "word: resulting": 3,
                "word: optional": 3,
                "word: sanitize": 9,
                "word: parameter": 10,
                "word: checked": 3,
                "word: possible": 3,
                "word: malicious": 3,
                "word: attempts": 3,
                "word: called": 5,
                "word: detected": 3,
                "word: unfilterjson": 9,
                "word: isjson": 7,
                "word: syntaxerror": 3,
                "word: formed": 3,
                "word: evalscripts": 6,
                "word: content": 5,
                "word: present": 5,
                "word: containing": 3,
                "word: returned": 8,
                "word: scripttags": 16,
                "word: extractscripts": 7,
                "word: results": 7,
                "word: extracts": 2,
                "word: strings": 4,
                "word: matchall": 4,
                "word: matchone": 4,
                "word: scriptmatches": 8,
                "word: occurances": 5,
                "word: replaced": 5,
                "word: either": 7,
                "word: regular": 7,
                "word: internally": 9,
                "word: replace": 39,
                "word: replacement": 35,
                "word: matched": 7,
                "word: patterns": 7,
                "word: isfunction": 4,
                "word: quicker": 2,
                "word: contains": 2,
                "word: include": 2,
                "word: indexof": 8,
                "word: oriented": 3,
                "word: wrapped": 3,
                "word: single": 6,
                "word: double": 6,
                "word: quotes": 12,
                "word: backslashes": 3,
                "word: escaped": 3,
                "word: usedoublequotes": 9,
                "word: escape": 3,
                "word: inspect": 5,
                "word: escapedstring": 9,
                "word: charcodeat": 5,
                "word: topaddedstring": 3,
                "word: treats": 3,
                "word: template": 6,
                "word: properties": 3,
                "word: values": 3,
                "word: default": 12,
                "word: attribute": 3,
                "word: interpolate": 3,
                "word: expressions": 2,
                "word: security": 2,
                "word: method": 7,
                "word: eaeflnr": 2,
                "word: beginning": 6,
                "word: startswith": 2,
                "word: strips": 7,
                "word: anything": 4,
                "word: stripscripts": 2,
                "word: striptags": 5,
                "word: integer": 5,
                "word: number": 7,
                "word: global": 2,
                "word: sarray": 16,
                "word: typeof": 4,
                "word: unshift": 2,
                "word: fromcharcode": 2,
                "word: concatenate": 4,
                "word: copies": 2,
                "word: together": 2,
                "word: repeat": 2,
                "word: tojson": 2,
                "word: parses": 2,
                "word: composed": 2,
                "word: mainly": 2,
                "word: targeted": 2,
                "word: parsing": 2,
                "word: seperator": 2,
                "word: argument": 2,
                "word: reason": 2,
                "word: consider": 2,
                "word: before": 2,
                "word: question": 2,
                "word: signals": 2,
                "word: beyond": 2,
                "word: symbol": 2,
                "word: decodeuricomponent": 6,
                "word: separator": 6,
                "word: separate": 2,
                "word: parameters": 2,
                "word: toqueryparams": 5,
                "word: paramslist": 6,
                "word: params": 16,
                "word: undefined": 2,
                "word: truncate": 6,
                "word: truncates": 2,
                "word: appends": 2,
                "word: suffix": 2,
                "word: indicating": 2,
                "word: excerpt": 2,
                "word: truncation": 16,
                "word: truncated": 2,
                "word: camelized": 3,
                "word: series": 3,
                "word: borderbottomwidth": 3,
                "word: border": 3,
                "word: bottom": 3,
                "word: unescapehtml": 6,
                "word: normal": 3,
                "word: filter": 15,
                "word: filtered": 9,
                "word: convenience": 3,
                "word: parsequery": 3,
                "special: jquery.string": 3,
                "special: 1.1.0": 3,
                "special: stilldesigning.com": 3,
                "special: 2008-2011": 3,
                "special: prototypejs.org": 3,
                "special: 2005-2011": 3,
                "special: p.source": 6,
                "special: p.ignoreCase": 1,
                "special: p.multiline": 3,
                "special: this.str": 54,
                "special: 1.6.0.2": 31,
                "special: this.JSONFilter": 2,
                "special: this.ScriptFragment": 4,
                "special: this.specialChar": 2,
                "special: white-space": 3,
                "special: this.blank": 5,
                "special: this.s": 73,
                "special: foo-bar": 3,
                "special: this.camelize": 3,
                "special: a.length": 2,
                "special: s.push": 2,
                "special: s.join": 2,
                "special: this.capitalize": 2,
                "special: s.charAt": 1,
                "special: s.substring": 4,
                "special: this.dasherize": 2,
                "special: this.empty": 2,
                "special: this.endsWith": 1,
                "special: s.length": 13,
                "special: pattern.length": 2,
                "special: s.lastIndexOf": 2,
                "special: Prototype-1": 11,
                "special: this.escapeHTML": 1,
                "special: this.evalJSON": 1,
                "special: this.unfilterJSON": 2,
                "special: this.isJSON": 2,
                "special: this.evalScripts": 1,
                "special: this.extractScripts": 2,
                "special: scriptTags.length": 2,
                "special: results.push": 2,
                "special: scriptMatches.length": 2,
                "special: scriptTags.push": 1,
                "special: this.gsub": 12,
                "special: s.match": 7,
                "special: this.sub": 5,
                "special: match.length": 2,
                "special: s.split": 4,
                "special: this.include": 2,
                "special: i.e": 3,
                "special: debug-oriented": 3,
                "special: double-quotes": 3,
                "special: single-quotes": 3,
                "special: this.inspect": 5,
                "special: escapedString.replace": 2,
                "special: Prototype-style": 1,
                "special: Ruby-style": 1,
                "special: this.interpolate": 3,
                "special: pattern.match": 3,
                "special: pattern.exec": 2,
                "special: s.replace": 2,
                "special: 0-9": 2,
                "special: Eaeflnr-u": 1,
                "special: this.scan": 2,
                "special: this.startsWith": 1,
                "special: this.strip": 2,
                "special: this.stripScripts": 1,
                "special: this.stripTags": 2,
                "special: 1:count": 3,
                "special: matches.length": 6,
                "special: s.indexOf": 2,
                "special: sarray.unshift": 2,
                "special: sarray.push": 2,
                "special: length-1": 4,
                "special: sarray.length": 2,
                "special: i-1": 4,
                "special: this.succ": 2,
                "special: s.slice": 5,
                "special: String.fromCharCode": 1,
                "special: s.charCodeAt": 1,
                "special: this.times": 2,
                "special: this.toJSON": 1,
                "special: parameter/value": 4,
                "special: URI-like": 1,
                "special: this.toQueryParams": 1,
                "special: paramsList.length": 1,
                "special: this.truncate": 2,
                "special: truncation.length": 3,
                "special: e.g": 3,
                "special: this.underscore": 3,
                "special: str.toLowerCase": 1,
                "special: A-Z": 4,
                "special: a-z": 14,
                "special: m.toLowerCase": 1,
                "special: this.str.substring": 6,
                "special: this.unescapeHTML": 1,
                "special: str.replace": 3,
                "special: this.value": 3,
                "special: s:this": 3,
                "special: String.prototype": 2,
                "special: stringPrototype.parseQuery": 1,
                "special: stringPrototype.toQueryParams": 1,
                "/** * jquery.string - prototype string functions for jquery * version: 1.1.0 * (c) 2008-2011 david e. still (http://stilldesigning.com) * original prototype extensions (c) 2005-2011 sam stephenson (http://prototypejs.org) */ (function($){ $.extend({ __stringprototype: function(str){ var splitcheck = (\"a b\".split(/\\w/)[0] == \" \")": 2,
                "// test for crappy ie matching (feature sniffing instead of version sniffing) function makeregexpglobal(p) { if (!p.source) { return p": 2,
                "} var mods = \"g\"+((p.ignorecase)?\"i\":\"\")+((p.multiline)?\"m\":\"\")": 2,
                "return new regexp(p.source, mods)": 2,
                "} this.str = str": 2,
                "/** * scriptfragmet, specialchar, and jsonfilter borrowed from prototype 1.6.0.2 */ this.jsonfilter = /^\\/\\*-secure-([\\s\\s]*)\\*\\/\\s*$/": 2,
                "this.scriptfragment = ' ]*>([\\\\s\\\\s]*?) '": 1,
                "this.specialchar = { '\\b': '\\\\b', '\\t': '\\\\t', '\\n': '\\\\n', '\\f': '\\\\f', '\\r': '\\\\r', '\\\\': '\\\\\\\\' }": 2,
                "/** * check if the string is blank (white-space only or empty). * @param {string} s string to be evaluated * @return {boolean} boolean of result */ this.blank = function(s) { return /^\\s*$/.test(this.s(s) || ' ')": 2,
                "/** * converts a string separated by dashes into a camelcase equivalent. * for instance, 'foo-bar' would be converted to 'foobar'. * @param {string} s string to be evaluated * @return {boolean} boolean of result */ this.camelize = function(s) { var a = this.s(s).split('-'), i": 2,
                "i = 0 s.lastindexof(pattern) === d": 1,
                "/** * escapehtml from prototype-1.6.0.2 -- if it's good enough for webkit and ie, it's good enough for gecko! * converts html special characters to their entity equivalents. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.escapehtml = function(s) { this.str = this.s(s) .split(' ').join(' ') .split(' ').join(' ')": 1,
                "/** * evaljson from prototype-1.6.0.2 * evaluates the json in the string and returns the resulting object. if the optional sanitize parameter * is set to true, the string is checked for possible malicious attempts and eval is not called if one * is detected. * @param {string} s string to be evaluated * @return {object} evaluated json result */ this.evaljson = function(sanitize, s) { s = this.s(s)": 2,
                "var json = this.unfilterjson(false, s).str": 2,
                "try { if (!sanitize || this.isjson(json)) { return eval('(' + json + ')')": 2,
                "} } catch (e) { } throw new syntaxerror('badly formed json string: ' + s)": 2,
                "/** * evalscripts from prototype-1.6.0.2 * evaluates the content of any script block present in the string. returns an array containing * the value returned by each script. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.evalscripts = function(s) { var scripttags = this.extractscripts(this.s(s)), results = []": 2,
                "if (scripttags.length > 0) { for (var i = 0": 2,
                "i 0) { for (var i = 0": 1,
                "/** * returns a debug-oriented version of the string (i.e. wrapped in single or double quotes, * with backslashes and quotes escaped). * @param {object} usedoublequotes escape double-quotes instead of single-quotes * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.inspect = function(usedoublequotes, s) { s = this.s(s)": 2,
                "var specialchar = this.specialchar, escapedstring = this.gsub(/[\\x00-\\x1f\\\\]/, function(match) { var character = specialchar[match[0]]": 2,
                "return character ? character : '\\\\u00' + match[0].charcodeat().topaddedstring(2, 16)": 2,
                "this.str = (usedoublequotes) ? '\"' + escapedstring.replace(/\"/g, '\\\\\"') + '\"' : \"'\" + escapedstring.replace(/'/g, '\\\\\\'') + \"'\"": 2,
                "/** * treats the string as a prototype-style template and fills it with object": 2,
                "s properties. * @param {object} obj object of values to replace in string * @param {object} pattern regex pattern for template replacement (default matches ruby-style '#{attribute}') * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.interpolate = function(obj, pattern, s) { s = this.s(s)": 2,
                "} var count = 0, length = s.length, match": 2,
                "while (pattern.match(s) count++ ]+>/gi, '')": 1,
                "/** * returns a string with the first count occurances of pattern replaced by either a regular string * or the returned value of a function. * @param {object} pattern regex pattern or string to replace * @param {object} replacement string or function to replace matched patterns * @param {integer} count number of (default = 1, -1 replaces all) * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.sub = function(pattern, replacement, count, s) { s = this.s(s)": 2,
                "if (count length) ? s.slice(0, length - truncation.length) + truncation : string(s)": 1,
                "/** * underscore from prototype-1.6.0.2 * converts a camelized string into a series of words separated by an underscore (\"_\"). * e.g. $.string('borderbottomwidth').underscore().str = 'border_bottom_width' * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.underscore = function(s) { //s = this.s(s)": 2,
                "//this.str = $.string(s).gsub(/::/, \"/\").gsub(/([a-z]+)([a-z][a-z])/, \"#{1}_#{2}\").gsub(/([a-z\\d])([a-z])/, \"#{1}_#{2}\").gsub(/-/, \"_\").str.tolowercase()": 2,
                "this.gsub(/[a-z]/, function(m){ return \"_\" + m.tolowercase()": 2,
                "if (this.str.substring(0,1) == \"_\") { this.str = this.str.substring(1)": 2,
                "} return this": 2,
                "/** * unescapehtml from prototype-1.6.0.2 -- if it's good enough for webkit and ie, it's good enough for gecko! * strips tags and converts the entity forms of special html characters to their normal form. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.unescapehtml = function(s) { this.str = this.striptags(this.s(s)).str.replace(/ /g,' ').replace(/ /g,' ')": 1,
                "/** * unfilterjson from prototype-1.6.0.2. * @param {function} filter * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.unfilterjson = function(filter, s) { s = this.s(s)": 2,
                "filter = filter || this.jsonfilter": 2,
                "/** * value -- convenience method to return .str */ this.value = function() { return this.str": 2,
                "/** * fetch str internally if no parameter is given */ this.s = function(s) { return (s)?s:this.str": 2,
                "}, string: function(str) { if (str === string.prototype) { $.extend(string.prototype, new $.__stringprototype())": 2,
                "} else { return new $.__stringprototype(str)": 2,
                "} } })": 2,
                "$.__stringprototype.parsequery = $.__stringprototype.toqueryparams": 2,
                "})(jquery)": 2,
                "special: p.ignorecase": 2,
                "special: this.jsonfilter": 4,
                "special: this.scriptfragment": 5,
                "special: this.specialchar": 4,
                "special: s.lastindexof": 3,
                "special: this.escapehtml": 2,
                "special: this.evaljson": 2,
                "special: this.unfilterjson": 4,
                "special: this.isjson": 3,
                "special: this.evalscripts": 2,
                "special: this.extractscripts": 3,
                "special: scripttags.length": 3,
                "special: escapedstring.replace": 4,
                "special: prototype-1": 17,
                "special: prototype-style": 2,
                "special: str.tolowercase": 2,
                "special: m.tolowercase": 2,
                "special: this.unescapehtml": 2,
                "special: this.striptags": 3,
                "special: string.prototype": 4,
                "special: stringprototype.parsequery": 2,
                "special: stringprototype.toqueryparams": 2,
                "special: ruby-style": 2,
                "this.scriptfragment = '<script[^>]*>([\\\\s\\\\s]*?)<\\/script>'": 1,
                "i++){ s.push(a[i].charat(0).touppercase() + a[i].substring(1))": 1,
                "} this.str=s.join(\"\")": 1,
                "/** * capitalizes the first letter of a string and downcases all the others. * @param {string} s string to be evaluated * @return {boolean} boolean of result */ this.capitalize=function(s) { s=this.s(s)": 1,
                "this.str=s.charat(0).touppercase() + s.substring(1).tolowercase()": 1,
                "/** * replaces every instance of the underscore character (\"_\") by a dash (\"-\"). * @param {string} s string to be evaluated * @return {boolean} boolean of result */ this.dasherize=function(s) { this.str=this.s(s).split(\"_\").join(\"-\")": 1,
                "/** * check if the string is empty. * @param {string} s string to be evaluated * @return {boolean} boolean of result */ this.empty=function(s) { return (s)?(s==\"\"):(this.str==\"\")": 1,
                "/** * tests whether the end of a string matches pattern. * @param {object} pattern * @param {string} s string to be evaluated * @return {boolean} boolean of result */ this.endswith=function(pattern, s) { s=this.s(s)": 1,
                "var d=s.length - pattern.length": 1,
                "return d>= 0 && s.lastindexof(pattern) === d": 1,
                "/** * escapehtml from prototype-1.6.0.2 -- if it's good enough for webkit and ie, it's good enough for gecko! * converts html special characters to their entity equivalents. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.escapehtml = function(s) { this.str = this.s(s) .split('&').join('&') .split('<').join('&lt": 1,
                "') .split('>').join('>')": 1,
                "i <scripttags.length": 1,
                "i++) { results.push(eval(scripttags[i]))": 1,
                "} } return results": 1,
                "/** * extractscripts from prototype-1.6.0.2 * extracts the content of any script block present in the string and returns them as an array of strings. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.extractscripts=function(s) { var matchall=new regexp(this.scriptfragment, 'img'), matchone=new regexp(this.scriptfragment, 'im'), scriptmatches=this.s(s).match(matchall) || [], scripttags=[]": 1,
                "if (scriptmatches.length>0) { for (var i = 0": 1,
                "i <scriptmatches.length": 1,
                "i++) { scripttags.push(scriptmatches[i].match(matchone)[1] || '')": 1,
                "} } return scripttags": 1,
                "/** * returns a string with all occurances of pattern replaced by either a regular string * or the returned value of a function. calls sub internally. * @param {object} pattern regex pattern or string to replace * @param {object} replacement string or function to replace matched patterns * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) * @see sub */ this.gsub=function(pattern, replacement, s) { s=this.s(s)": 1,
                "if ($.isfunction(replacement)) { var match=s.match(makeregexpglobal(pattern))": 1,
                "if (match== null) { return this": 1,
                "} s=this.sub(pattern, replacement, match.length, s).str": 1,
                "} /* if replacement is not a function, do this the easy way": 1,
                "it's quicker */ else { s=s.split(pattern).join(replacement)": 1,
                "} this.str=s": 2,
                "/** * check if the string contains a substring. * @param {object} pattern regex pattern or string to find * @param {string} s string to be evaluated * @return {boolean} boolean result */ this.include=function(pattern, s) { return this.s(s).indexof(pattern)>-1": 1,
                "while (pattern.match(s) && count++ <length) { match=pattern.exec(s)": 1,
                "s=this.gsub(match[2],obj[match[3]], s).str": 1,
                "/** * isjson from prototype-1.6.0.2 * check if the string is valid json by the use of regular expressions. this security method is called internally. * @param {string} s string to be evaluated * @return {boolean} boolean result */ this.isjson=function(s) { s=this.s(s)": 1,
                "} s=s.replace(/\\\\./g, '@').replace(/\"[^\"\\\\\\n\\r]*\"/g, '')": 1,
                "return (/^[,:{}\\[\\]0-9.\\-+eaeflnr-u \\n\\r\\t]*$/).test(s)": 1,
                "/** * evaluates replacement for each match of pattern in string and returns the original string. * calls sub internally. * @param {object} pattern regex pattern or string to replace * @param {object} replacement string or function to replace matched patterns * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) * @see sub */ this.scan=function(pattern, replacement, s) { s=this.s(s)": 1,
                "this.gsub(pattern, replacement, s).str=s": 1,
                "/** * tests whether the beginning of a string matches pattern. * @param {object} pattern * @param {string} s string to be evaluated * @return {boolean} boolean of result */ this.startswith=function(pattern, s) { return this.s(s).indexof(pattern)=== 0": 1,
                "/** * trims white space from the beginning and end of a string. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.strip=function(s) { this.str=$.trim(this.s(s))": 1,
                "/** * strips a string of anything that looks like an html script block. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.stripscripts=function(s) { this.str=this.s(s).replace(new regexp(this.scriptfragment, 'img'), '')": 1,
                "/** * strips a string of any html tags. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.striptags=function(s) { this.str=this.s(s).replace(/<\\/?[^>]+>/gi, '')": 1,
                "if (count <0 || isnan(count)) { return this": 1,
                "} // make regexp global pattern=makeregexpglobal(pattern)": 1,
                "var sarray=s.split(pattern), matches=s.match(pattern)": 1,
                "if (splitcheck && typeof(pattern)== \"object\") { if (count== matches.length) ++count": 1,
                "if (s.indexof(matches[0])== 0) sarray.unshift(\"\")": 1,
                "if (s.lastindexof(matches[matches.length-1])== s.length - matches[matches.length-1].length) sarray.push(\"\")": 1,
                "} s=sarray[0]": 1,
                "i++) { if (i <=count) { if ($.isfunction(replacement)) { s +=replacement(matches[i-1] || matches) + sarray[i]": 1,
                "} else { s +=replacement + sarray[i]": 1,
                "} } else { s +=(matches[i-1] || matches) + sarray[i]": 1,
                "} } this.str=s": 1,
                "/** * succ from prototype-1.6.0.2 * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.succ=function(s) { s=this.s(s)": 1,
                "this.str=s.slice(0, s.length - 1) + string.fromcharcode(s.charcodeat(s.length - 1) + 1)": 1,
                "/** * times from prototype-1.6.0.2 * concatenate count number of copies of s together and return result. * @param {integer} count number of times to repeat s * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.times=function(count, s) { this.str=count < 1 ? \"\" : (new array(count + 1)).join(this.s(s))": 1,
                "/** * returns a json string * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.tojson=function(s) { return this.inspect(true, this.s(s))": 1,
                "/** * parses a uri-like query string and returns an object composed of parameter/value pairs. * this method is mainly targeted at parsing query strings (hence the default value of '&' * for the seperator argument). for this reason, it does not consider anything that is either * before a question mark (which signals the beginning of a query string) or beyond the hash * symbol (\"#\"), and runs decodeuricomponent() on each parameter/value pair. * @param {object} separator string to separate parameters (default=\"&\" ) * @param {object} s * @return {object} object */ this.toqueryparams=function(separator, s) { s=this.s(s)": 1,
                "var paramslist=s.substring(s.indexof(\"?\")+1).split(\"#\")[0].split(separator || '&'), params={}, i, key, value, pair": 1,
                "i<paramslist.length": 1,
                "i++) { pair=paramslist[i].split(\"=\")": 1,
                "key=decodeuricomponent(pair[0])": 1,
                "value=(pair[1])?decodeuricomponent(pair[1]):undefined": 1,
                "if (params[key]) { if (typeof params[key]== \"string\") { params[key]=[params[key]]": 1,
                "} params[key].push(value)": 1,
                "} else { params[key]=value": 1,
                "} } return params": 1,
                "/** * truncate from prototype-1.6.0.2 * truncates a string to the given length and appends a suffix to it (indicating that it is only an excerpt). * @param {object} length length of string to truncate to * @param {object} truncation string to concatenate onto truncated string (default=\"...\" ) * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.truncate=function(length, truncation, s) { s=this.s(s)": 1,
                "length=length || 30": 1,
                "truncation=(!truncation) ? '...' : truncation": 1,
                "s=(s.length>length) ? s.slice(0, length - truncation.length) + truncation : string(s)": 1,
                "/** * unescapehtml from prototype-1.6.0.2 -- if it's good enough for webkit and ie, it's good enough for gecko! * strips tags and converts the entity forms of special html characters to their normal form. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.unescapehtml = function(s) { this.str = this.striptags(this.s(s)).str.replace(/&/g,'&').replace(/</g,'<').replace(/&gt": 1,
                "special: s.charat": 1,
                "special: this.endswith": 1,
                "special: scriptmatches.length": 2,
                "special: scripttags.push": 1,
                "special: this.startswith": 1,
                "special: this.stripscripts": 1,
                "special: s.indexof": 2,
                "special: string.fromcharcode": 1,
                "special: s.charcodeat": 1,
                "special: this.tojson": 1,
                "special: this.toqueryparams": 1,
                "special: paramslist.length": 1,
                "special: eaeflnr-u": 1,
                "special: uri-like": 1
            }
        },
        {
            "plugin": "extractors.meta",
            "version": "0.1",
            "results": {
                "clamav: Cannot dlopen libclamunrar_iface: file not found - unrar support unavailable": 1,
                "clamav: cli_loadftm: File type signature for Microsoft Windows Shortcut File not loaded (required f-level: 1??)": 1,
                "clamav: [Bytecode JIT]; emitted ELF64-x86-64 <in-memory object> of 7?? bytes": 1,
                "clamav: bytecode self test running": 1,
                "clamav: Bytecode 4?????????: executing in JIT mode": 1,
                "clamav: bytecode finished in 1 us": 1,
                "clamav: bytecode self test succeeded": 1,
                "clamav: [Bytecode JIT]; emitted ELF64-x86-64 <in-memory object> of 1????? bytes": 1,
                "clamav: Bytecode: 94 bytecode prepared with JIT": 1,
                "clamav: Recognized ASCII text": 1,
                "clamav: Matched signature for file type HTML data at 7??": 1,
                "clamav: in cli_scanhtml()": 1,
                "clamav: cli_pcre_match: pcre_exec: match limit exceeded": 1,
                "clamav: cli_pcre_report: error occurred in pcre_match: -8": 1,
                "clamav: cli_magic_scandesc: returning 0  at line 2???": 1,
                "clamav: malware family: OK": 1,
                "clamav: OK": 1,
                "clamav: Scanned files: 1": 1,
                "clamav: Infected files: 0": 1,
                "clamav: extracted blobs": 1,
                "clamav: extracted 1 blobs": 1,
                "clamav: blob size: 4???": 1,
                "clamav: Cannot dlopen libclamunrar_iface: file not found - unrar support unavailable;clamav: cli_loadftm: File type signature for Microsoft Windows Shortcut File not loaded (required f-level: 1??)": 1,
                "clamav: cli_loadftm: File type signature for Microsoft Windows Shortcut File not loaded (required f-level: 1??);clamav: [Bytecode JIT]; emitted ELF64-x86-64 <in-memory object> of 7?? bytes": 1,
                "clamav: [Bytecode JIT]; emitted ELF64-x86-64 <in-memory object> of 7?? bytes;clamav: bytecode self test running": 1,
                "clamav: bytecode self test running;clamav: Bytecode 4?????????: executing in JIT mode": 1,
                "clamav: Bytecode 4?????????: executing in JIT mode;clamav: bytecode finished in 1 us": 1,
                "clamav: bytecode finished in 1 us;clamav: bytecode self test succeeded": 1,
                "clamav: bytecode self test succeeded;clamav: [Bytecode JIT]; emitted ELF64-x86-64 <in-memory object> of 1????? bytes": 1,
                "clamav: [Bytecode JIT]; emitted ELF64-x86-64 <in-memory object> of 1????? bytes;clamav: Bytecode: 94 bytecode prepared with JIT": 1,
                "clamav: Bytecode: 94 bytecode prepared with JIT;clamav: Recognized ASCII text": 1,
                "clamav: Recognized ASCII text;clamav: Matched signature for file type HTML data at 7??": 1,
                "clamav: Matched signature for file type HTML data at 7??;clamav: in cli_scanhtml()": 1,
                "clamav: in cli_scanhtml();clamav: cli_pcre_match: pcre_exec: match limit exceeded": 1,
                "clamav: cli_pcre_match: pcre_exec: match limit exceeded;clamav: cli_pcre_report: error occurred in pcre_match: -8": 1,
                "clamav: cli_pcre_report: error occurred in pcre_match: -8;clamav: cli_magic_scandesc: returning 0  at line 2???": 1,
                "clamav: cli_magic_scandesc: returning 0  at line 2???;clamav: malware family: OK": 1,
                "clamav: malware family: OK;clamav: OK": 1,
                "clamav: OK;clamav: Scanned files: 1": 1,
                "clamav: Scanned files: 1;clamav: Infected files: 0": 1,
                "clamav: Infected files: 0;clamav: extracted blobs": 1,
                "clamav: extracted blobs;clamav: extracted 1 blobs": 1,
                "clamav: extracted 1 blobs;clamav: blob size: 4???": 1,
                "File type: UTF-8 Unicode text": 1,
                "File type segment: UTF-8 Unicode text": 1,
                "File type word: UTF-8": 1,
                "File type word: Unicode": 1,
                "File type word: text": 1,
                "Extracted blob: ISO-8859 text, with very long lines, with no line terminators": 1,
                "Extracted blob: UTF-8 Unicode text, with very long lines, with no line terminators": 1,
                "blob file types: ISO-8859, UTF-8": 1
            }
        }
    ]
}