/** * jquery.string - prototype string functions for jquery * version: 1.1.0 * (c) 2008-2011 david e. still (http://stilldesigning.com) * original prototype extensions (c) 2005-2011 sam stephenson (http://prototypejs.org) */ (function($){ $.extend({ __stringprototype: function(str){ var splitcheck = ("a b".split(/\w/)[0] == " "); // test for crappy ie matching (feature sniffing instead of version sniffing) function makeregexpglobal(p) { if (!p.source) { return p; } var mods = "g"+((p.ignorecase)?"i":"")+((p.multiline)?"m":""); return new regexp(p.source, mods); } this.str = str; /** * scriptfragmet, specialchar, and jsonfilter borrowed from prototype 1.6.0.2 */ this.jsonfilter = /^\/\*-secure-([\s\s]*)\*\/\s*$/; this.scriptfragment = '<script[^>]*>([\\s\\s]*?)<\/script>'; this.specialchar = { '\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', '\\': '\\\\' }; /** * check if the string is blank (white-space only or empty). * @param {string} s string to be evaluated * @return {boolean} boolean of result */ this.blank = function(s) { return /^\s*$/.test(this.s(s) || ' '); }; /** * converts a string separated by dashes into a camelcase equivalent. * for instance, 'foo-bar' would be converted to 'foobar'. * @param {string} s string to be evaluated * @return {boolean} boolean of result */ this.camelize = function(s) { var a = this.s(s).split('-'), i; s = [a[0]]; for (i=1; i<a.length; i++){ s.push(a[i].charat(0).touppercase() + a[i].substring(1)); } this.str=s.join(""); return this; }; /** * capitalizes the first letter of a string and downcases all the others. * @param {string} s string to be evaluated * @return {boolean} boolean of result */ this.capitalize=function(s) { s=this.s(s); this.str=s.charat(0).touppercase() + s.substring(1).tolowercase(); return this; }; /** * replaces every instance of the underscore character ("_") by a dash ("-"). * @param {string} s string to be evaluated * @return {boolean} boolean of result */ this.dasherize=function(s) { this.str=this.s(s).split("_").join("-"); return this; }; /** * check if the string is empty. * @param {string} s string to be evaluated * @return {boolean} boolean of result */ this.empty=function(s) { return (s)?(s==""):(this.str==""); }; /** * tests whether the end of a string matches pattern. * @param {object} pattern * @param {string} s string to be evaluated * @return {boolean} boolean of result */ this.endswith=function(pattern, s) { s=this.s(s); var d=s.length - pattern.length; return d>= 0 && s.lastindexof(pattern) === d; }; /** * escapehtml from prototype-1.6.0.2 -- if it's good enough for webkit and ie, it's good enough for gecko! * converts html special characters to their entity equivalents. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.escapehtml = function(s) { this.str = this.s(s) .split('&').join('&') .split('<').join('&lt;') .split('>').join('>'); return this; }; /** * evaljson from prototype-1.6.0.2 * evaluates the json in the string and returns the resulting object. if the optional sanitize parameter * is set to true, the string is checked for possible malicious attempts and eval is not called if one * is detected. * @param {string} s string to be evaluated * @return {object} evaluated json result */ this.evaljson = function(sanitize, s) { s = this.s(s); var json = this.unfilterjson(false, s).str; try { if (!sanitize || this.isjson(json)) { return eval('(' + json + ')'); } } catch (e) { } throw new syntaxerror('badly formed json string: ' + s); }; /** * evalscripts from prototype-1.6.0.2 * evaluates the content of any script block present in the string. returns an array containing * the value returned by each script. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.evalscripts = function(s) { var scripttags = this.extractscripts(this.s(s)), results = []; if (scripttags.length > 0) { for (var i = 0; i <scripttags.length; i++) { results.push(eval(scripttags[i])); } } return results; }; /** * extractscripts from prototype-1.6.0.2 * extracts the content of any script block present in the string and returns them as an array of strings. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.extractscripts=function(s) { var matchall=new regexp(this.scriptfragment, 'img'), matchone=new regexp(this.scriptfragment, 'im'), scriptmatches=this.s(s).match(matchall) || [], scripttags=[]; if (scriptmatches.length>0) { for (var i = 0; i <scriptmatches.length; i++) { scripttags.push(scriptmatches[i].match(matchone)[1] || ''); } } return scripttags; }; /** * returns a string with all occurances of pattern replaced by either a regular string * or the returned value of a function. calls sub internally. * @param {object} pattern regex pattern or string to replace * @param {object} replacement string or function to replace matched patterns * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) * @see sub */ this.gsub=function(pattern, replacement, s) { s=this.s(s); if ($.isfunction(replacement)) { var match=s.match(makeregexpglobal(pattern)); if (match== null) { return this; } s=this.sub(pattern, replacement, match.length, s).str; } /* if replacement is not a function, do this the easy way; it's quicker */ else { s=s.split(pattern).join(replacement); } this.str=s; return this; }; /** * check if the string contains a substring. * @param {object} pattern regex pattern or string to find * @param {string} s string to be evaluated * @return {boolean} boolean result */ this.include=function(pattern, s) { return this.s(s).indexof(pattern)>-1; }; /** * returns a debug-oriented version of the string (i.e. wrapped in single or double quotes, * with backslashes and quotes escaped). * @param {object} usedoublequotes escape double-quotes instead of single-quotes * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.inspect = function(usedoublequotes, s) { s = this.s(s); var specialchar = this.specialchar, escapedstring = this.gsub(/[\x00-\x1f\\]/, function(match) { var character = specialchar[match[0]]; return character ? character : '\\u00' + match[0].charcodeat().topaddedstring(2, 16); }, s).str; this.str = (usedoublequotes) ? '"' + escapedstring.replace(/"/g, '\\"') + '"' : "'" + escapedstring.replace(/'/g, '\\\'') + "'"; return this; }; /** * treats the string as a prototype-style template and fills it with object√çs properties. * @param {object} obj object of values to replace in string * @param {object} pattern regex pattern for template replacement (default matches ruby-style '#{attribute}') * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.interpolate = function(obj, pattern, s) { s = this.s(s); if (!pattern) { pattern = /(^|.|\r|\n)(\#\{\s*(\w+)\s*\})/; } var count = 0, length = s.length, match; while (pattern.match(s) && count++ <length) { match=pattern.exec(s); s=this.gsub(match[2],obj[match[3]], s).str; } this.str=s; return this; }; /** * isjson from prototype-1.6.0.2 * check if the string is valid json by the use of regular expressions. this security method is called internally. * @param {string} s string to be evaluated * @return {boolean} boolean result */ this.isjson=function(s) { s=this.s(s); if (this.blank(s)) { return false; } s=s.replace(/\\./g, '@').replace(/"[^"\\\n\r]*"/g, ''); return (/^[,:{}\[\]0-9.\-+eaeflnr-u \n\r\t]*$/).test(s); }; /** * evaluates replacement for each match of pattern in string and returns the original string. * calls sub internally. * @param {object} pattern regex pattern or string to replace * @param {object} replacement string or function to replace matched patterns * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) * @see sub */ this.scan=function(pattern, replacement, s) { s=this.s(s); this.gsub(pattern, replacement, s).str=s; return this; }; /** * tests whether the beginning of a string matches pattern. * @param {object} pattern * @param {string} s string to be evaluated * @return {boolean} boolean of result */ this.startswith=function(pattern, s) { return this.s(s).indexof(pattern)=== 0; }; /** * trims white space from the beginning and end of a string. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.strip=function(s) { this.str=$.trim(this.s(s)); return this; }; /** * strips a string of anything that looks like an html script block. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.stripscripts=function(s) { this.str=this.s(s).replace(new regexp(this.scriptfragment, 'img'), ''); return this; }; /** * strips a string of any html tags. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.striptags=function(s) { this.str=this.s(s).replace(/<\/?[^>]+>/gi, ''); return this; }; /** * returns a string with the first count occurances of pattern replaced by either a regular string * or the returned value of a function. * @param {object} pattern regex pattern or string to replace * @param {object} replacement string or function to replace matched patterns * @param {integer} count number of (default = 1, -1 replaces all) * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.sub = function(pattern, replacement, count, s) { s = this.s(s); count = (!count)?1:count; if (count <0 || isnan(count)) { return this; } // make regexp global pattern=makeregexpglobal(pattern); var sarray=s.split(pattern), matches=s.match(pattern); if (splitcheck && typeof(pattern)== "object") { if (count== matches.length) ++count; if (s.indexof(matches[0])== 0) sarray.unshift(""); if (s.lastindexof(matches[matches.length-1])== s.length - matches[matches.length-1].length) sarray.push(""); } s=sarray[0]; for (var i=1; i<sarray.length; i++) { if (i <=count) { if ($.isfunction(replacement)) { s +=replacement(matches[i-1] || matches) + sarray[i]; } else { s +=replacement + sarray[i]; } } else { s +=(matches[i-1] || matches) + sarray[i]; } } this.str=s; return this; }; /** * succ from prototype-1.6.0.2 * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.succ=function(s) { s=this.s(s); this.str=s.slice(0, s.length - 1) + string.fromcharcode(s.charcodeat(s.length - 1) + 1); return this; }; /** * times from prototype-1.6.0.2 * concatenate count number of copies of s together and return result. * @param {integer} count number of times to repeat s * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.times=function(count, s) { this.str=count < 1 ? "" : (new array(count + 1)).join(this.s(s)); return this; }; /** * returns a json string * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.tojson=function(s) { return this.inspect(true, this.s(s)); }; /** * parses a uri-like query string and returns an object composed of parameter/value pairs. * this method is mainly targeted at parsing query strings (hence the default value of '&' * for the seperator argument). for this reason, it does not consider anything that is either * before a question mark (which signals the beginning of a query string) or beyond the hash * symbol ("#"), and runs decodeuricomponent() on each parameter/value pair. * @param {object} separator string to separate parameters (default="&" ) * @param {object} s * @return {object} object */ this.toqueryparams=function(separator, s) { s=this.s(s); var paramslist=s.substring(s.indexof("?")+1).split("#")[0].split(separator || '&'), params={}, i, key, value, pair; for (i=0; i<paramslist.length; i++) { pair=paramslist[i].split("="); key=decodeuricomponent(pair[0]); value=(pair[1])?decodeuricomponent(pair[1]):undefined; if (params[key]) { if (typeof params[key]== "string") { params[key]=[params[key]]; } params[key].push(value); } else { params[key]=value; } } return params; }; /** * truncate from prototype-1.6.0.2 * truncates a string to the given length and appends a suffix to it (indicating that it is only an excerpt). * @param {object} length length of string to truncate to * @param {object} truncation string to concatenate onto truncated string (default="..." ) * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.truncate=function(length, truncation, s) { s=this.s(s); length=length || 30; truncation=(!truncation) ? '...' : truncation; s=(s.length>length) ? s.slice(0, length - truncation.length) + truncation : string(s); this.str = s; return this; }; /** * underscore from prototype-1.6.0.2 * converts a camelized string into a series of words separated by an underscore ("_"). * e.g. $.string('borderbottomwidth').underscore().str = 'border_bottom_width' * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.underscore = function(s) { //s = this.s(s); //this.str = $.string(s).gsub(/::/, "/").gsub(/([a-z]+)([a-z][a-z])/, "#{1}_#{2}").gsub(/([a-z\d])([a-z])/, "#{1}_#{2}").gsub(/-/, "_").str.tolowercase(); this.gsub(/[a-z]/, function(m){ return "_" + m.tolowercase(); }, this.s(s)); if (this.str.substring(0,1) == "_") { this.str = this.str.substring(1); } return this; }; /** * unescapehtml from prototype-1.6.0.2 -- if it's good enough for webkit and ie, it's good enough for gecko! * strips tags and converts the entity forms of special html characters to their normal form. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.unescapehtml = function(s) { this.str = this.striptags(this.s(s)).str.replace(/&/g,'&').replace(/</g,'<').replace(/&gt;/g,'>'); return this; }; /** * unfilterjson from prototype-1.6.0.2. * @param {function} filter * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.unfilterjson = function(filter, s) { s = this.s(s); filter = filter || this.jsonfilter; var filtered = s.match(filter); this.str = (filtered !== null)?filtered[1]:s; return this; }; /** * value -- convenience method to return .str */ this.value = function() { return this.str; }; /** * fetch str internally if no parameter is given */ this.s = function(s) { return (s)?s:this.str; }; }, string: function(str) { if (str === string.prototype) { $.extend(string.prototype, new $.__stringprototype()); } else { return new $.__stringprototype(str); } } }); $.__stringprototype.parsequery = $.__stringprototype.toqueryparams; })(jquery);