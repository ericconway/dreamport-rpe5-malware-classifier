/** * jquery.string - prototype string functions for jquery * version: 1.1.0 * (c) 2008-2011 david e. still (http://stilldesigning.com) * original prototype extensions (c) 2005-2011 sam stephenson (http://prototypejs.org) */ (function($){ $.extend({ __stringprototype: function(str){ var splitcheck = ("a b".split(/\w/)[0] == " "); // test for crappy ie matching (feature sniffing instead of version sniffing) function makeregexpglobal(p) { if (!p.source) { return p; } var mods = "g"+((p.ignorecase)?"i":"")+((p.multiline)?"m":""); return new regexp(p.source, mods); } this.str = str; /** * scriptfragmet, specialchar, and jsonfilter borrowed from prototype 1.6.0.2 */ this.jsonfilter = /^\/\*-secure-([\s\s]*)\*\/\s*$/; this.scriptfragment = ' ]*>([\\s\\s]*?) '; this.specialchar = { '\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', '\\': '\\\\' }; /** * check if the string is blank (white-space only or empty). * @param {string} s string to be evaluated * @return {boolean} boolean of result */ this.blank = function(s) { return /^\s*$/.test(this.s(s) || ' '); }; /** * converts a string separated by dashes into a camelcase equivalent. * for instance, 'foo-bar' would be converted to 'foobar'. * @param {string} s string to be evaluated * @return {boolean} boolean of result */ this.camelize = function(s) { var a = this.s(s).split('-'), i; s = [a[0]]; for (i=1; i = 0 s.lastindexof(pattern) === d; }; /** * escapehtml from prototype-1.6.0.2 -- if it's good enough for webkit and ie, it's good enough for gecko! * converts html special characters to their entity equivalents. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.escapehtml = function(s) { this.str = this.s(s) .split(' ').join(' ') .split(' ').join(' '); return this; }; /** * evaljson from prototype-1.6.0.2 * evaluates the json in the string and returns the resulting object. if the optional sanitize parameter * is set to true, the string is checked for possible malicious attempts and eval is not called if one * is detected. * @param {string} s string to be evaluated * @return {object} evaluated json result */ this.evaljson = function(sanitize, s) { s = this.s(s); var json = this.unfilterjson(false, s).str; try { if (!sanitize || this.isjson(json)) { return eval('(' + json + ')'); } } catch (e) { } throw new syntaxerror('badly formed json string: ' + s); }; /** * evalscripts from prototype-1.6.0.2 * evaluates the content of any script block present in the string. returns an array containing * the value returned by each script. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.evalscripts = function(s) { var scripttags = this.extractscripts(this.s(s)), results = []; if (scripttags.length > 0) { for (var i = 0; i 0) { for (var i = 0; i -1; }; /** * returns a debug-oriented version of the string (i.e. wrapped in single or double quotes, * with backslashes and quotes escaped). * @param {object} usedoublequotes escape double-quotes instead of single-quotes * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.inspect = function(usedoublequotes, s) { s = this.s(s); var specialchar = this.specialchar, escapedstring = this.gsub(/[\x00-\x1f\\]/, function(match) { var character = specialchar[match[0]]; return character ? character : '\\u00' + match[0].charcodeat().topaddedstring(2, 16); }, s).str; this.str = (usedoublequotes) ? '"' + escapedstring.replace(/"/g, '\\"') + '"' : "'" + escapedstring.replace(/'/g, '\\\'') + "'"; return this; }; /** * treats the string as a prototype-style template and fills it with objectÃÃs properties. * @param {object} obj object of values to replace in string * @param {object} pattern regex pattern for template replacement (default matches ruby-style '#{attribute}') * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.interpolate = function(obj, pattern, s) { s = this.s(s); if (!pattern) { pattern = /(^|.|\r|\n)(\#\{\s*(\w+)\s*\})/; } var count = 0, length = s.length, match; while (pattern.match(s) count++ ]+>/gi, ''); return this; }; /** * returns a string with the first count occurances of pattern replaced by either a regular string * or the returned value of a function. * @param {object} pattern regex pattern or string to replace * @param {object} replacement string or function to replace matched patterns * @param {integer} count number of (default = 1, -1 replaces all) * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.sub = function(pattern, replacement, count, s) { s = this.s(s); count = (!count)?1:count; if (count length) ? s.slice(0, length - truncation.length) + truncation : string(s); this.str = s; return this; }; /** * underscore from prototype-1.6.0.2 * converts a camelized string into a series of words separated by an underscore ("_"). * e.g. $.string('borderbottomwidth').underscore().str = 'border_bottom_width' * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.underscore = function(s) { //s = this.s(s); //this.str = $.string(s).gsub(/::/, "/").gsub(/([a-z]+)([a-z][a-z])/, "#{1}_#{2}").gsub(/([a-z\d])([a-z])/, "#{1}_#{2}").gsub(/-/, "_").str.tolowercase(); this.gsub(/[a-z]/, function(m){ return "_" + m.tolowercase(); }, this.s(s)); if (this.str.substring(0,1) == "_") { this.str = this.str.substring(1); } return this; }; /** * unescapehtml from prototype-1.6.0.2 -- if it's good enough for webkit and ie, it's good enough for gecko! * strips tags and converts the entity forms of special html characters to their normal form. * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.unescapehtml = function(s) { this.str = this.striptags(this.s(s)).str.replace(/ /g,' ').replace(/ /g,' '); return this; }; /** * unfilterjson from prototype-1.6.0.2. * @param {function} filter * @param {string} s string to be evaluated * @return {object} .string object (or string if internal) */ this.unfilterjson = function(filter, s) { s = this.s(s); filter = filter || this.jsonfilter; var filtered = s.match(filter); this.str = (filtered !== null)?filtered[1]:s; return this; }; /** * value -- convenience method to return .str */ this.value = function() { return this.str; }; /** * fetch str internally if no parameter is given */ this.s = function(s) { return (s)?s:this.str; }; }, string: function(str) { if (str === string.prototype) { $.extend(string.prototype, new $.__stringprototype()); } else { return new $.__stringprototype(str); } } }); $.__stringprototype.parsequery = $.__stringprototype.toqueryparams; })(jquery);