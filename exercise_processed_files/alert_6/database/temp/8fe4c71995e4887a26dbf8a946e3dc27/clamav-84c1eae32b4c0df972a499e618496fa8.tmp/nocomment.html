/** * bxslider v4.1.1 - fully loaded, responsive content slider * http://bxslider.com * * copyright 2012, steven wanderski - http://stevenwanderski.com - http://bxcreative.com * written while drinking belgian ales and listening to jazz * * released under the wtfpl license - http://sam.zoy.org/wtfpl/ */ ;(function($){ var plugin = {}; var defaults = { // general mode: 'horizontal', slideselector: '', infiniteloop: true, hidecontrolonend: false, speed: 500, easing: null, slidemargin: 0, startslide: 0, randomstart: false, captions: false, ticker: false, tickerhover: false, adaptiveheight: false, adaptiveheightspeed: 500, video: false, usecss: true, preloadimages: 'visible', responsive: true, // touch touchenabled: true, swipethreshold: 50, onetoonetouch: true, preventdefaultswipex: true, preventdefaultswipey: false, // pager pager: true, pagertype: 'full', pagershortseparator: ' / ', pagerselector: null, buildpager: null, pagercustom: null, // controls controls: true, nexttext: 'next', prevtext: 'prev', nextselector: null, prevselector: null, autocontrols: false, starttext: 'start', stoptext: 'stop', autocontrolscombine: false, autocontrolsselector: null, // auto auto: false, pause: 4000, autostart: true, autodirection: 'next', autohover: false, autodelay: 0, // carousel minslides: 1, maxslides: 1, moveslides: 0, slidewidth: 0, // callbacks onsliderload: function() {}, onslidebefore: function() {}, onslideafter: function() {}, onslidenext: function() {}, onslideprev: function() {} } $.fn.bxslider = function(options){ if(this.length == 0) return this; // support mutltiple elements if(this.length > 1){ this.each(function(){$(this).bxslider(options)}); return this; } // create a namespace to be used throughout the plugin var slider = {}; // set a reference to our slider element var el = this; plugin.el = this; /** * makes slideshow responsive */ // first get the original window dimens (thanks alot ie) var windowwidth = $(window).width(); var windowheight = $(window).height(); /** * =================================================================================== * = private functions * =================================================================================== */ /** * initializes namespace settings to be used throughout plugin */ var init = function(){ // merge user-supplied options with the defaults slider.settings = $.extend({}, defaults, options); // parse slidewidth setting slider.settings.slidewidth = parseint(slider.settings.slidewidth); // store the original children slider.children = el.children(slider.settings.slideselector); // check if actual number of slides is less than minslides / maxslides if(slider.children.length <slider.settings.minslides) slider.settings.minslides=slider.children.length; if(slider.children.length < slider.settings.maxslides) slider.settings.maxslides=slider.children.length; // if random start, set the startslide setting to random number if(slider.settings.randomstart) slider.settings.startslide=math.floor(math.random() * slider.children.length); // store active slide information slider.active={ index: slider.settings.startslide } // store if the slider is in carousel mode (displaying / moving multiple slides) slider.carousel=slider.settings.minslides>1 || slider.settings.maxslides > 1; // if carousel, force preloadimages = 'all' if(slider.carousel) slider.settings.preloadimages = 'all'; // calculate the min / max width thresholds based on min / max number of slides // used to setup and update carousel slides dimensions slider.minthreshold = (slider.settings.minslides * slider.settings.slidewidth) + ((slider.settings.minslides - 1) * slider.settings.slidemargin); slider.maxthreshold = (slider.settings.maxslides * slider.settings.slidewidth) + ((slider.settings.maxslides - 1) * slider.settings.slidemargin); // store the current state of the slider (if currently animating, working is true) slider.working = false; // initialize the controls object slider.controls = {}; // initialize an auto interval slider.interval = null; // determine which property to use for transitions slider.animprop = slider.settings.mode == 'vertical' ? 'top' : 'left'; // determine if hardware acceleration can be used slider.usingcss = slider.settings.usecss && slider.settings.mode != 'fade' && (function(){ // create our test div element var div = document.createelement('div'); // css transition properties var props = ['webkitperspective', 'mozperspective', 'operspective', 'msperspective']; // test for each property for(var i in props){ if(div.style[props[i]] !== undefined){ slider.cssprefix = props[i].replace('perspective', '').tolowercase(); slider.animprop = '-' + slider.cssprefix + '-transform'; return true; } } return false; }()); // if vertical mode always make maxslides and minslides equal if(slider.settings.mode == 'vertical') slider.settings.maxslides = slider.settings.minslides; // save original style data el.data("origstyle", el.attr("style")); el.children(slider.settings.slideselector).each(function() { $(this).data("origstyle", $(this).attr("style")); }); // perform all dom / css modifications setup(); } /** * performs all dom and css modifications */ var setup = function(){ // wrap el in a wrapper el.wrap('<div class="bx-wrapper"><div class="bx-viewport"></div></div>'); // store a namspace reference to .bx-viewport slider.viewport = el.parent(); // add a loading div to display while images are loading slider.loader = $('<div class="bx-loading" />'); slider.viewport.prepend(slider.loader); // set el to a massive width, to hold any needed slides // also strip any margin and padding from el el.css({ width: slider.settings.mode == 'horizontal' ? (slider.children.length * 100 + 215) + '%' : 'auto', position: 'relative' }); // if using css, add the easing property if(slider.usingcss && slider.settings.easing){ el.css('-' + slider.cssprefix + '-transition-timing-function', slider.settings.easing); // if not using css and no easing value was supplied, use the default js animation easing (swing) }else if(!slider.settings.easing){ slider.settings.easing = 'swing'; } var slidesshowing = getnumberslidesshowing(); // make modifications to the viewport (.bx-viewport) slider.viewport.css({ width: '100%', overflow: 'hidden', position: 'relative' }); slider.viewport.parent().css({ maxwidth: getviewportmaxwidth() }); // make modification to the wrapper (.bx-wrapper) if(!slider.settings.pager) { slider.viewport.parent().css({ margin: '0 auto 0px' }); } // apply css to all slider children slider.children.css({ 'float': slider.settings.mode == 'horizontal' ? 'left' : 'none', liststyle: 'none', position: 'relative' }); // apply the calculated width after the float is applied to prevent scrollbar interference slider.children.css('width', getslidewidth()); // if slidemargin is supplied, add the css if(slider.settings.mode == 'horizontal' && slider.settings.slidemargin > 0) slider.children.css('marginright', slider.settings.slidemargin); if(slider.settings.mode == 'vertical' && slider.settings.slidemargin > 0) slider.children.css('marginbottom', slider.settings.slidemargin); // if "fade" mode, add positioning and z-index css if(slider.settings.mode == 'fade'){ slider.children.css({ position: 'absolute', zindex: 0, display: 'none' }); // prepare the z-index on the showing element slider.children.eq(slider.settings.startslide).css({zindex: 50, display: 'block'}); } // create an element to contain all slider controls (pager, start / stop, etc) slider.controls.el = $('<div class="bx-controls" />'); // if captions are requested, add them if(slider.settings.captions) appendcaptions(); // check if startslide is last slide slider.active.last = slider.settings.startslide == getpagerqty() - 1; // if video is true, set up the fitvids plugin if(slider.settings.video) el.fitvids(); // set the default preload selector (visible) var preloadselector = slider.children.eq(slider.settings.startslide); if (slider.settings.preloadimages == "all") preloadselector = slider.children; // only check for control addition if not in "ticker" mode if(!slider.settings.ticker){ // if pager is requested, add it if(slider.settings.pager) appendpager(); // if controls are requested, add them if(slider.settings.controls) appendcontrols(); // if auto is true, and auto controls are requested, add them if(slider.settings.auto && slider.settings.autocontrols) appendcontrolsauto(); // if any control option is requested, add the controls wrapper if(slider.settings.controls || slider.settings.autocontrols || slider.settings.pager) slider.viewport.after(slider.controls.el); // if ticker mode, do not allow a pager }else{ slider.settings.pager = false; } // preload all images, then perform final dom / css modifications that depend on images being loaded loadelements(preloadselector, start); } var loadelements = function(selector, callback){ var total = selector.find('img, iframe').length; if (total == 0){ callback(); return; } var count = 0; selector.find('img, iframe').each(function(){ if($(this).is('img')) $(this).attr('src', $(this).attr('src') + '?timestamp=' + new date().gettime()); $(this).load(function(){ settimeout(function(){ if(++count == total) callback(); }, 0) }); }); } /** * start the slider */ var start = function(){ // if infinite loop, prepare additional slides if(slider.settings.infiniteloop && slider.settings.mode != 'fade' && !slider.settings.ticker){ var slice = slider.settings.mode == 'vertical' ? slider.settings.minslides : slider.settings.maxslides; var sliceappend = slider.children.slice(0, slice).clone().addclass('bx-clone'); var sliceprepend = slider.children.slice(-slice).clone().addclass('bx-clone'); el.append(sliceappend).prepend(sliceprepend); } // remove the loading dom element slider.loader.remove(); // set the left / top position of "el" setslideposition(); // if "vertical" mode, always use adaptiveheight to prevent odd behavior if (slider.settings.mode == 'vertical') slider.settings.adaptiveheight = true; // set the viewport height slider.viewport.height(getviewportheight()); // make sure everything is positioned just right (same as a window resize) el.redrawslider(); // onsliderload callback slider.settings.onsliderload(slider.active.index); // slider has been fully initialized slider.initialized = true; // bind the resize call to the window if (slider.settings.responsive) $(window).bind('resize', resizewindow); // if auto is true, start the show if (slider.settings.auto && slider.settings.autostart) initauto(); // if ticker is true, start the ticker if (slider.settings.ticker) initticker(); // if pager is requested, make the appropriate pager link active if (slider.settings.pager) updatepageractive(slider.settings.startslide); // check for any updates to the controls (like hidecontrolonend updates) if (slider.settings.controls) updatedirectioncontrols(); // if touchenabled is true, setup the touch events if (slider.settings.touchenabled && !slider.settings.ticker) inittouch(); } /** * returns the calculated height of the viewport, used to determine either adaptiveheight or the maxheight value */ var getviewportheight = function(){ var height = 0; // first determine which children (slides) should be used in our height calculation var children = $(); // if mode is not "vertical" and adaptiveheight is false, include all children if(slider.settings.mode != 'vertical' && !slider.settings.adaptiveheight){ children = slider.children; }else{ // if not carousel, return the single active child if(!slider.carousel){ children = slider.children.eq(slider.active.index); // if carousel, return a slice of children }else{ // get the individual slide index var currentindex = slider.settings.moveslides == 1 ? slider.active.index : slider.active.index * getmoveby(); // add the current slide to the children children = slider.children.eq(currentindex); // cycle through the remaining "showing" slides for (i = 1; i <= slider.settings.maxslides - 1; i++){ // if looped back to the start if(currentindex + i>= slider.children.length){ children = children.add(slider.children.eq(i - 1)); }else{ children = children.add(slider.children.eq(currentindex + i)); } } } } // if "vertical" mode, calculate the sum of the heights of the children if(slider.settings.mode == 'vertical'){ children.each(function(index) { height += $(this).outerheight(); }); // add user-supplied margins if(slider.settings.slidemargin > 0){ height += slider.settings.slidemargin * (slider.settings.minslides - 1); } // if not "vertical" mode, calculate the max height of the children }else{ height = math.max.apply(math, children.map(function(){ return $(this).outerheight(false); }).get()); } return height; } /** * returns the calculated width to be used for the outer wrapper / viewport */ var getviewportmaxwidth = function(){ var width = '100%'; if(slider.settings.slidewidth > 0){ if(slider.settings.mode == 'horizontal'){ width = (slider.settings.maxslides * slider.settings.slidewidth) + ((slider.settings.maxslides - 1) * slider.settings.slidemargin); }else{ width = slider.settings.slidewidth; } } return width; } /** * returns the calculated width to be applied to each slide */ var getslidewidth = function(){ // start with any user-supplied slide width var newelwidth = slider.settings.slidewidth; // get the current viewport width var wrapwidth = slider.viewport.width(); // if slide width was not supplied, or is larger than the viewport use the viewport width if(slider.settings.slidewidth == 0 || (slider.settings.slidewidth > wrapwidth && !slider.carousel) || slider.settings.mode == 'vertical'){ newelwidth = wrapwidth; // if carousel, use the thresholds to determine the width }else if(slider.settings.maxslides > 1 && slider.settings.mode == 'horizontal'){ if(wrapwidth > slider.maxthreshold){ // newelwidth = (wrapwidth - (slider.settings.slidemargin * (slider.settings.maxslides - 1))) / slider.settings.maxslides; }else if(wrapwidth <slider.minthreshold){ newelwidth=(wrapwidth - (slider.settings.slidemargin * (slider.settings.minslides - 1))) / slider.settings.minslides; } } return newelwidth; } /** * returns the number of slides currently visible in the viewport (includes partially visible slides) */ var getnumberslidesshowing=function(){ var slidesshowing=1; if(slider.settings.mode== 'horizontal' && slider.settings.slidewidth>0){ // if viewport is smaller than minthreshold, return minslides if(slider.viewport.width() <slider.minthreshold){ slidesshowing=slider.settings.minslides; // if viewport is larger than minthreshold, return maxslides }else if(slider.viewport.width()>slider.maxthreshold){ slidesshowing = slider.settings.maxslides; // if viewport is between min / max thresholds, divide viewport width by first child width }else{ var childwidth = slider.children.first().width(); slidesshowing = math.floor(slider.viewport.width() / childwidth); } // if "vertical" mode, slides showing will always be minslides }else if(slider.settings.mode == 'vertical'){ slidesshowing = slider.settings.minslides; } return slidesshowing; } /** * returns the number of pages (one full viewport of slides is one "page") */ var getpagerqty = function(){ var pagerqty = 0; // if moveslides is specified by the user if(slider.settings.moveslides > 0){ if(slider.settings.infiniteloop){ pagerqty = slider.children.length / getmoveby(); }else{ // use a while loop to determine pages var breakpoint = 0; var counter = 0 // when breakpoint goes above children length, counter is the number of pages while (breakpoint <slider.children.length){ ++pagerqty; breakpoint=counter + getnumberslidesshowing(); counter +=slider.settings.moveslides <=getnumberslidesshowing() ? slider.settings.moveslides : getnumberslidesshowing(); } } // if moveslides is 0 (auto) divide children length by sides showing, then round up }else{ pagerqty=math.ceil(slider.children.length / getnumberslidesshowing()); } return pagerqty; } /** * returns the number of indivual slides by which to shift the slider */ var getmoveby=function(){ // if moveslides was set by the user and moveslides is less than number of slides showing if(slider.settings.moveslides>0 && slider.settings.moveslides <= getnumberslidesshowing()){ return slider.settings.moveslides; } // if moveslides is 0 (auto) return getnumberslidesshowing(); } /** * sets the slider's (el) left or top position */ var setslideposition=function(){ // if last slide, not infinite loop, and number of children is larger than specified maxslides if(slider.children.length>slider.settings.maxslides && slider.active.last && !slider.settings.infiniteloop){ if (slider.settings.mode == 'horizontal'){ // get the last child's position var lastchild = slider.children.last(); var position = lastchild.position(); // set the left position setpositionproperty(-(position.left - (slider.viewport.width() - lastchild.width())), 'reset', 0); }else if(slider.settings.mode == 'vertical'){ // get the last showing index's position var lastshowingindex = slider.children.length - slider.settings.minslides; var position = slider.children.eq(lastshowingindex).position(); // set the top position setpositionproperty(-position.top, 'reset', 0); } // if not last slide }else{ // get the position of the first showing slide var position = slider.children.eq(slider.active.index * getmoveby()).position(); // check for last slide if (slider.active.index == getpagerqty() - 1) slider.active.last = true; // set the repective position if (position != undefined){ if (slider.settings.mode == 'horizontal') setpositionproperty(-position.left, 'reset', 0); else if (slider.settings.mode == 'vertical') setpositionproperty(-position.top, 'reset', 0); } } } /** * sets the el's animating property position (which in turn will sometimes animate el). * if using css, sets the transform property. if not using css, sets the top / left property. * * @param value (int) * - the animating property's value * * @param type (string) 'slider', 'reset', 'ticker' * - the type of instance for which the function is being * * @param duration (int) * - the amount of time (in ms) the transition should occupy * * @param params (array) optional * - an optional parameter containing any variables that need to be passed in */ var setpositionproperty = function(value, type, duration, params){ // use css transform if(slider.usingcss){ // determine the translate3d value var propvalue = slider.settings.mode == 'vertical' ? 'translate3d(0, ' + value + 'px, 0)' : 'translate3d(' + value + 'px, 0, 0)'; // add the css transition-duration el.css('-' + slider.cssprefix + '-transition-duration', duration / 1000 + 's'); if(type == 'slide'){ // set the property value el.css(slider.animprop, propvalue); // bind a callback method - executes when css transition completes el.bind('transitionend webkittransitionend otransitionend mstransitionend', function(){ // unbind the callback el.unbind('transitionend webkittransitionend otransitionend mstransitionend'); updateafterslidetransition(); }); }else if(type == 'reset'){ el.css(slider.animprop, propvalue); }else if(type == 'ticker'){ // make the transition use 'linear' el.css('-' + slider.cssprefix + '-transition-timing-function', 'linear'); el.css(slider.animprop, propvalue); // bind a callback method - executes when css transition completes el.bind('transitionend webkittransitionend otransitionend mstransitionend', function(){ // unbind the callback el.unbind('transitionend webkittransitionend otransitionend mstransitionend'); // reset the position setpositionproperty(params['resetvalue'], 'reset', 0); // start the loop again tickerloop(); }); } // use js animate }else{ var animateobj = {}; animateobj[slider.animprop] = value; if(type == 'slide'){ el.animate(animateobj, duration, slider.settings.easing, function(){ updateafterslidetransition(); }); }else if(type == 'reset'){ el.css(slider.animprop, value) }else if(type == 'ticker'){ el.animate(animateobj, speed, 'linear', function(){ setpositionproperty(params['resetvalue'], 'reset', 0); // run the recursive loop after animation tickerloop(); }); } } } /** * populates the pager with proper amount of pages */ var populatepager = function(){ var pagerhtml = ''; var pagerqty = getpagerqty(); // loop through each pager item for(var i=0; i <pagerqty; i++){ var linkcontent="" ; // if a buildpager function is supplied, use it to get pager link value, else use index + 1 if(slider.settings.buildpager && $.isfunction(slider.settings.buildpager)){ linkcontent=slider.settings.buildpager(i); slider.pagerel.addclass('bx-custom-pager'); }else{ linkcontent=i + 1; slider.pagerel.addclass('bx-default-pager'); } // var linkcontent=slider.settings.buildpager && $.isfunction(slider.settings.buildpager) ? slider.settings.buildpager(i) : i + 1; // add the markup to the string pagerhtml +="<div class="bx-pager-item"><a href="" data-slide-index="" + i + '" class="bx-pager-link">' + linkcontent + '</a></div>'; }; // populate the pager element with pager links slider.pagerel.html(pagerhtml); } /** * appends the pager to the controls element */ var appendpager = function(){ if(!slider.settings.pagercustom){ // create the pager dom element slider.pagerel = $('<div class="bx-pager" />'); // if a pager selector was supplied, populate it with the pager if(slider.settings.pagerselector){ $(slider.settings.pagerselector).html(slider.pagerel); // if no pager selector was supplied, add it after the wrapper }else{ slider.controls.el.addclass('bx-has-pager').append(slider.pagerel); } // populate the pager populatepager(); }else{ slider.pagerel = $(slider.settings.pagercustom); } // assign the pager click binding slider.pagerel.delegate('a', 'click', clickpagerbind); } /** * appends prev / next controls to the controls element */ var appendcontrols = function(){ slider.controls.next = $('<a class="bx-next" href="">' + slider.settings.nexttext + '</a>'); slider.controls.prev = $('<a class="bx-prev" href="">' + slider.settings.prevtext + '</a>'); // bind click actions to the controls slider.controls.next.bind('click', clicknextbind); slider.controls.prev.bind('click', clickprevbind); // if nextslector was supplied, populate it if(slider.settings.nextselector){ $(slider.settings.nextselector).append(slider.controls.next); } // if prevslector was supplied, populate it if(slider.settings.prevselector){ $(slider.settings.prevselector).append(slider.controls.prev); } // if no custom selectors were supplied if(!slider.settings.nextselector && !slider.settings.prevselector){ // add the controls to the dom slider.controls.directionel = $('<div class="bx-controls-direction" />'); // add the control elements to the directionel slider.controls.directionel.append(slider.controls.prev).append(slider.controls.next); // slider.viewport.append(slider.controls.directionel); slider.controls.el.addclass('bx-has-controls-direction').append(slider.controls.directionel); } } /** * appends start / stop auto controls to the controls element */ var appendcontrolsauto = function(){ slider.controls.start = $('<div class="bx-controls-auto-item"><a class="bx-start" href="">' + slider.settings.starttext + '</a></div>'); slider.controls.stop = $('<div class="bx-controls-auto-item"><a class="bx-stop" href="">' + slider.settings.stoptext + '</a></div>'); // add the controls to the dom slider.controls.autoel = $('<div class="bx-controls-auto" />'); // bind click actions to the controls slider.controls.autoel.delegate('.bx-start', 'click', clickstartbind); slider.controls.autoel.delegate('.bx-stop', 'click', clickstopbind); // if autocontrolscombine, insert only the "start" control if(slider.settings.autocontrolscombine){ slider.controls.autoel.append(slider.controls.start); // if autocontrolscombine is false, insert both controls }else{ slider.controls.autoel.append(slider.controls.start).append(slider.controls.stop); } // if auto controls selector was supplied, populate it with the controls if(slider.settings.autocontrolsselector){ $(slider.settings.autocontrolsselector).html(slider.controls.autoel); // if auto controls selector was not supplied, add it after the wrapper }else{ slider.controls.el.addclass('bx-has-controls-auto').append(slider.controls.autoel); } // update the auto controls updateautocontrols(slider.settings.autostart ? 'stop' : 'start'); } /** * appends image captions to the dom */ var appendcaptions = function(){ // cycle through each child slider.children.each(function(index){ // get the image title attribute var title = $(this).find('img:first').attr('title'); // append the caption if (title != undefined && ('' + title).length) { $(this).append('<div class="bx-caption"><span>' + title + '</span></div>'); } }); } /** * click next binding * * @param e (event) * - dom event object */ var clicknextbind = function(e){ // if auto show is running, stop it if (slider.settings.auto) el.stopauto(); el.gotonextslide(); e.preventdefault(); } /** * click prev binding * * @param e (event) * - dom event object */ var clickprevbind = function(e){ // if auto show is running, stop it if (slider.settings.auto) el.stopauto(); el.gotoprevslide(); e.preventdefault(); } /** * click start binding * * @param e (event) * - dom event object */ var clickstartbind = function(e){ el.startauto(); e.preventdefault(); } /** * click stop binding * * @param e (event) * - dom event object */ var clickstopbind = function(e){ el.stopauto(); e.preventdefault(); } /** * click pager binding * * @param e (event) * - dom event object */ var clickpagerbind = function(e){ // if auto show is running, stop it if (slider.settings.auto) el.stopauto(); var pagerlink = $(e.currenttarget); var pagerindex = parseint(pagerlink.attr('data-slide-index')); // if clicked pager link is not active, continue with the gotoslide call if(pagerindex != slider.active.index) el.gotoslide(pagerindex); e.preventdefault(); } /** * updates the pager links with an active class * * @param slideindex (int) * - index of slide to make active */ var updatepageractive = function(slideindex){ // if "short" pager type var len = slider.children.length; // nb of children if(slider.settings.pagertype == 'short'){ if(slider.settings.maxslides > 1) { len = math.ceil(slider.children.length/slider.settings.maxslides); } slider.pagerel.html( (slideindex + 1) + slider.settings.pagershortseparator + len); return; } // remove all pager active classes slider.pagerel.find('a').removeclass('active'); // apply the active class for all pagers slider.pagerel.each(function(i, el) { $(el).find('a').eq(slideindex).addclass('active'); }); } /** * performs needed actions after a slide transition */ var updateafterslidetransition = function(){ // if infinte loop is true if(slider.settings.infiniteloop){ var position = ''; // first slide if(slider.active.index == 0){ // set the new position position = slider.children.eq(0).position(); // carousel, last slide }else if(slider.active.index == getpagerqty() - 1 && slider.carousel){ position = slider.children.eq((getpagerqty() - 1) * getmoveby()).position(); // last slide }else if(slider.active.index == slider.children.length - 1){ position = slider.children.eq(slider.children.length - 1).position(); } if (slider.settings.mode == 'horizontal') { setpositionproperty(-position.left, 'reset', 0);; } else if (slider.settings.mode == 'vertical') { setpositionproperty(-position.top, 'reset', 0);; } } // declare that the transition is complete slider.working = false; // onslideafter callback slider.settings.onslideafter(slider.children.eq(slider.active.index), slider.oldindex, slider.active.index); } /** * updates the auto controls state (either active, or combined switch) * * @param state (string) "start", "stop" * - the new state of the auto show */ var updateautocontrols = function(state){ // if autocontrolscombine is true, replace the current control with the new state if(slider.settings.autocontrolscombine){ slider.controls.autoel.html(slider.controls[state]); // if autocontrolscombine is false, apply the "active" class to the appropriate control }else{ slider.controls.autoel.find('a').removeclass('active'); slider.controls.autoel.find('a:not(.bx-' + state + ')').addclass('active'); } } /** * updates the direction controls (checks if either should be hidden) */ var updatedirectioncontrols = function(){ if(getpagerqty() == 1){ slider.controls.prev.addclass('disabled'); slider.controls.next.addclass('disabled'); }else if(!slider.settings.infiniteloop && slider.settings.hidecontrolonend){ // if first slide if (slider.active.index == 0){ slider.controls.prev.addclass('disabled'); slider.controls.next.removeclass('disabled'); // if last slide }else if(slider.active.index == getpagerqty() - 1){ slider.controls.next.addclass('disabled'); slider.controls.prev.removeclass('disabled'); // if any slide in the middle }else{ slider.controls.prev.removeclass('disabled'); slider.controls.next.removeclass('disabled'); } } } /** * initialzes the auto process */ var initauto = function(){ // if autodelay was supplied, launch the auto show using a settimeout() call if(slider.settings.autodelay > 0){ var timeout = settimeout(el.startauto, slider.settings.autodelay); // if autodelay was not supplied, start the auto show normally }else{ el.startauto(); } // if autohover is requested if(slider.settings.autohover){ // on el hover el.hover(function(){ // if the auto show is currently playing (has an active interval) if(slider.interval){ // stop the auto show and pass true agument which will prevent control update el.stopauto(true); // create a new autopaused value which will be used by the relative "mouseout" event slider.autopaused = true; } }, function(){ // if the autopaused value was created be the prior "mouseover" event if(slider.autopaused){ // start the auto show and pass true agument which will prevent control update el.startauto(true); // reset the autopaused value slider.autopaused = null; } }); } } /** * initialzes the ticker process */ var initticker = function(){ var startposition = 0; // if autodirection is "next", append a clone of the entire slider if(slider.settings.autodirection == 'next'){ el.append(slider.children.clone().addclass('bx-clone')); // if autodirection is "prev", prepend a clone of the entire slider, and set the left position }else{ el.prepend(slider.children.clone().addclass('bx-clone')); var position = slider.children.first().position(); startposition = slider.settings.mode == 'horizontal' ? -position.left : -position.top; } setpositionproperty(startposition, 'reset', 0); // do not allow controls in ticker mode slider.settings.pager = false; slider.settings.controls = false; slider.settings.autocontrols = false; // if autohover is requested if(slider.settings.tickerhover && !slider.usingcss){ // on el hover slider.viewport.hover(function(){ el.stop(); }, function(){ // calculate the total width of children (used to calculate the speed ratio) var totaldimens = 0; slider.children.each(function(index){ totaldimens += slider.settings.mode == 'horizontal' ? $(this).outerwidth(true) : $(this).outerheight(true); }); // calculate the speed ratio (used to determine the new speed to finish the paused animation) var ratio = slider.settings.speed / totaldimens; // determine which property to use var property = slider.settings.mode == 'horizontal' ? 'left' : 'top'; // calculate the new speed var newspeed = ratio * (totaldimens - (math.abs(parseint(el.css(property))))); tickerloop(newspeed); }); } // start the ticker loop tickerloop(); } /** * runs a continuous loop, news ticker-style */ var tickerloop = function(resumespeed){ speed = resumespeed ? resumespeed : slider.settings.speed; var position = {left: 0, top: 0}; var reset = {left: 0, top: 0}; // if "next" animate left position to last child, then reset left to 0 if(slider.settings.autodirection == 'next'){ position = el.find('.bx-clone').first().position(); // if "prev" animate left position to 0, then reset left to first non-clone child }else{ reset = slider.children.first().position(); } var animateproperty = slider.settings.mode == 'horizontal' ? -position.left : -position.top; var resetvalue = slider.settings.mode == 'horizontal' ? -reset.left : -reset.top; var params = {resetvalue: resetvalue}; setpositionproperty(animateproperty, 'ticker', speed, params); } /** * initializes touch events */ var inittouch = function(){ // initialize object to contain all touch values slider.touch = { start: {x: 0, y: 0}, end: {x: 0, y: 0} } slider.viewport.bind('touchstart', ontouchstart); } /** * event handler for "touchstart" * * @param e (event) * - dom event object */ var ontouchstart = function(e){ if(slider.working){ e.preventdefault(); }else{ // record the original position when touch starts slider.touch.originalpos = el.position(); var orig = e.originalevent; // record the starting touch x, y coordinates slider.touch.start.x = orig.changedtouches[0].pagex; slider.touch.start.y = orig.changedtouches[0].pagey; // bind a "touchmove" event to the viewport slider.viewport.bind('touchmove', ontouchmove); // bind a "touchend" event to the viewport slider.viewport.bind('touchend', ontouchend); } } /** * event handler for "touchmove" * * @param e (event) * - dom event object */ var ontouchmove = function(e){ var orig = e.originalevent; // if scrolling on y axis, do not prevent default var xmovement = math.abs(orig.changedtouches[0].pagex - slider.touch.start.x); var ymovement = math.abs(orig.changedtouches[0].pagey - slider.touch.start.y); // x axis swipe if((xmovement * 3) > ymovement && slider.settings.preventdefaultswipex){ e.preventdefault(); // y axis swipe }else if((ymovement * 3) > xmovement && slider.settings.preventdefaultswipey){ e.preventdefault(); } if(slider.settings.mode != 'fade' && slider.settings.onetoonetouch){ var value = 0; // if horizontal, drag along x axis if(slider.settings.mode == 'horizontal'){ var change = orig.changedtouches[0].pagex - slider.touch.start.x; value = slider.touch.originalpos.left + change; // if vertical, drag along y axis }else{ var change = orig.changedtouches[0].pagey - slider.touch.start.y; value = slider.touch.originalpos.top + change; } setpositionproperty(value, 'reset', 0); } } /** * event handler for "touchend" * * @param e (event) * - dom event object */ var ontouchend = function(e){ slider.viewport.unbind('touchmove', ontouchmove); var orig = e.originalevent; var value = 0; // record end x, y positions slider.touch.end.x = orig.changedtouches[0].pagex; slider.touch.end.y = orig.changedtouches[0].pagey; // if fade mode, check if absolute x distance clears the threshold if(slider.settings.mode == 'fade'){ var distance = math.abs(slider.touch.start.x - slider.touch.end.x); if(distance >= slider.settings.swipethreshold){ slider.touch.start.x > slider.touch.end.x ? el.gotonextslide() : el.gotoprevslide(); el.stopauto(); } // not fade mode }else{ var distance = 0; // calculate distance and el's animate property if(slider.settings.mode == 'horizontal'){ distance = slider.touch.end.x - slider.touch.start.x; value = slider.touch.originalpos.left; }else{ distance = slider.touch.end.y - slider.touch.start.y; value = slider.touch.originalpos.top; } // if not infinite loop and first / last slide, do not attempt a slide transition if(!slider.settings.infiniteloop && ((slider.active.index == 0 && distance > 0) || (slider.active.last && distance <0))){ setpositionproperty(value, 'reset', 200); }else{ // check if distance clears threshold if(math.abs(distance)>= slider.settings.swipethreshold){ distance <0 ? el.gotonextslide() : el.gotoprevslide(); el.stopauto(); }else{ // el.animate(property, 200); setpositionproperty(value, 'reset', 200); } } } slider.viewport.unbind('touchend', ontouchend); } /** * window resize event callback */ var resizewindow=function(e){ // get the new window dimens (again, thank you ie) var windowwidthnew=$(window).width(); var windowheightnew=$(window).height(); // make sure that it is a true window resize // *we must check this because our dinosaur friend ie fires a window resize event when certain dom elements // are resized. can you just die already?* if(windowwidth !=windowwidthnew || windowheight !=windowheightnew){ // set the new window dimens windowwidth=windowwidthnew; windowheight=windowheightnew; // update all dynamic elements el.redrawslider(); } } /** *=================================================================================== *=public functions *=================================================================================== */ /** * performs slide transition to the specified slide * * @param slideindex (int) * - the destination slide's index (zero-based) * * @param direction (string) * - internal use only - the direction of travel ("prev" / "next") */ el.gotoslide=function(slideindex, direction){ // if plugin is currently in motion, ignore request if(slider.working || slider.active.index== slideindex) return; // declare that plugin is in motion slider.working=true; // store the old index slider.oldindex=slider.active.index; // if slideindex is less than zero, set active index to last child (this happens during infinite loop) if(slideindex < 0){ slider.active.index=getpagerqty() - 1; // if slideindex is greater than children length, set active index to 0 (this happens during infinite loop) }else if(slideindex>= getpagerqty()){ slider.active.index = 0; // set active index to requested slide }else{ slider.active.index = slideindex; } // onslidebefore, onslidenext, onslideprev callbacks slider.settings.onslidebefore(slider.children.eq(slider.active.index), slider.oldindex, slider.active.index); if(direction == 'next'){ slider.settings.onslidenext(slider.children.eq(slider.active.index), slider.oldindex, slider.active.index); }else if(direction == 'prev'){ slider.settings.onslideprev(slider.children.eq(slider.active.index), slider.oldindex, slider.active.index); } // check if last slide slider.active.last = slider.active.index >= getpagerqty() - 1; // update the pager with active class if(slider.settings.pager) updatepageractive(slider.active.index); // // check for direction control update if(slider.settings.controls) updatedirectioncontrols(); // if slider is set to mode: "fade" if(slider.settings.mode == 'fade'){ // if adaptiveheight is true and next height is different from current height, animate to the new height if(slider.settings.adaptiveheight && slider.viewport.height() != getviewportheight()){ slider.viewport.animate({height: getviewportheight()}, slider.settings.adaptiveheightspeed); } // fade out the visible child and reset its z-index value slider.children.filter(':visible').fadeout(slider.settings.speed).css({zindex: 0}); // fade in the newly requested slide slider.children.eq(slider.active.index).css('zindex', 51).fadein(slider.settings.speed, function(){ $(this).css('zindex', 50); updateafterslidetransition(); }); // slider mode is not "fade" }else{ // if adaptiveheight is true and next height is different from current height, animate to the new height if(slider.settings.adaptiveheight && slider.viewport.height() != getviewportheight()){ slider.viewport.animate({height: getviewportheight()}, slider.settings.adaptiveheightspeed); } var moveby = 0; var position = {left: 0, top: 0}; // if carousel and not infinite loop if(!slider.settings.infiniteloop && slider.carousel && slider.active.last){ if(slider.settings.mode == 'horizontal'){ // get the last child position var lastchild = slider.children.eq(slider.children.length - 1); position = lastchild.position(); // calculate the position of the last slide moveby = slider.viewport.width() - lastchild.outerwidth(); }else{ // get last showing index position var lastshowingindex = slider.children.length - slider.settings.minslides; position = slider.children.eq(lastshowingindex).position(); } // horizontal carousel, going previous while on first slide (infiniteloop mode) }else if(slider.carousel && slider.active.last && direction == 'prev'){ // get the last child position var eq = slider.settings.moveslides == 1 ? slider.settings.maxslides - getmoveby() : ((getpagerqty() - 1) * getmoveby()) - (slider.children.length - slider.settings.maxslides); var lastchild = el.children('.bx-clone').eq(eq); position = lastchild.position(); // if infinite loop and "next" is clicked on the last slide }else if(direction == 'next' && slider.active.index == 0){ // get the last clone position position = el.find('> .bx-clone').eq(slider.settings.maxslides).position(); slider.active.last = false; // normal non-zero requests }else if(slideindex >= 0){ var requestel = slideindex * getmoveby(); position = slider.children.eq(requestel).position(); } /* if the position doesn't exist * (e.g. if you destroy the slider on a next click), * it doesn't throw an error. */ if ("undefined" !== typeof(position)) { var value = slider.settings.mode == 'horizontal' ? -(position.left - moveby) : -position.top; // plugin values to be animated setpositionproperty(value, 'slide', slider.settings.speed); } } } /** * transitions to the next slide in the show */ el.gotonextslide = function(){ // if infiniteloop is false and last page is showing, disregard call if (!slider.settings.infiniteloop && slider.active.last) return; var pagerindex = parseint(slider.active.index) + 1; el.gotoslide(pagerindex, 'next'); } /** * transitions to the prev slide in the show */ el.gotoprevslide = function(){ // if infiniteloop is false and last page is showing, disregard call if (!slider.settings.infiniteloop && slider.active.index == 0) return; var pagerindex = parseint(slider.active.index) - 1; el.gotoslide(pagerindex, 'prev'); } /** * starts the auto show * * @param preventcontrolupdate (boolean) * - if true, auto controls state will not be updated */ el.startauto = function(preventcontrolupdate){ // if an interval already exists, disregard call if(slider.interval) return; // create an interval slider.interval = setinterval(function(){ slider.settings.autodirection == 'next' ? el.gotonextslide() : el.gotoprevslide(); }, slider.settings.pause); // if auto controls are displayed and preventcontrolupdate is not true if (slider.settings.autocontrols && preventcontrolupdate != true) updateautocontrols('stop'); } /** * stops the auto show * * @param preventcontrolupdate (boolean) * - if true, auto controls state will not be updated */ el.stopauto = function(preventcontrolupdate){ // if no interval exists, disregard call if(!slider.interval) return; // clear the interval clearinterval(slider.interval); slider.interval = null; // if auto controls are displayed and preventcontrolupdate is not true if (slider.settings.autocontrols && preventcontrolupdate != true) updateautocontrols('start'); } /** * returns current slide index (zero-based) */ el.getcurrentslide = function(){ return slider.active.index; } /** * returns number of slides in show */ el.getslidecount = function(){ return slider.children.length; } /** * update all dynamic slider elements */ el.redrawslider = function(){ // resize all children in ratio to new screen size slider.children.add(el.find('.bx-clone')).outerwidth(getslidewidth()); // adjust the height slider.viewport.css('height', getviewportheight()); // update the slide position if(!slider.settings.ticker) setslideposition(); // if active.last was true before the screen resize, we want // to keep it last no matter what screen size we end on if (slider.active.last) slider.active.index = getpagerqty() - 1; // if the active index (page) no longer exists due to the resize, simply set the index as last if (slider.active.index >= getpagerqty()) slider.active.last = true; // if a pager is being displayed and a custom pager is not being used, update it if(slider.settings.pager && !slider.settings.pagercustom){ populatepager(); updatepageractive(slider.active.index); } } /** * destroy the current instance of the slider (revert everything back to original state) */ el.destroyslider = function(){ // don't do anything if slider has already been destroyed if(!slider.initialized) return; slider.initialized = false; $('.bx-clone', this).remove(); slider.children.each(function() { $(this).data("origstyle") != undefined ? $(this).attr("style", $(this).data("origstyle")) : $(this).removeattr('style'); }); $(this).data("origstyle") != undefined ? this.attr("style", $(this).data("origstyle")) : $(this).removeattr('style'); $(this).unwrap().unwrap(); if(slider.controls.el) slider.controls.el.remove(); if(slider.controls.next) slider.controls.next.remove(); if(slider.controls.prev) slider.controls.prev.remove(); if(slider.pagerel) slider.pagerel.remove(); $('.bx-caption', this).remove(); if(slider.controls.autoel) slider.controls.autoel.remove(); clearinterval(slider.interval); if(slider.settings.responsive) $(window).unbind('resize', resizewindow); } /** * reload the slider (revert all dom changes, and re-initialize) */ el.reloadslider = function(settings){ if (settings != undefined) options = settings; el.destroyslider(); init(); } init(); // returns the current jquery object return this; } })(jquery);